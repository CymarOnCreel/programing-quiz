INSERT INTO answers (answer_text,question_id, is_correct) VALUES
('Az eljárás-orientált nyelvek procedurális struktúrát használnak, míg az OOP objektumokon alapul.',1,1),
('Az absztrakció az, amikor csak a lényeges részleteket tartjuk meg egy objektumból, és elrejtjük a felesleges részleteket.',2,1),
('A megkülönböztetés az, amikor két különböző dolog közötti különbséget teszünk.',3,1),
('Az osztályozás az, amikor az objektumokat csoportokba rendezzük közös tulajdonságaik alapján.',4,1),
('Az általánosítás az, amikor egy általános osztályból származtatunk egy részletesebb osztályt. A specializálás fordított folyamat.',5,1),
('Objektumorientált programozás (OOP) az elvek és a paradigma alkalmazása a program tervezésére. Az öröklődés, az absztrakció, az inkapszuláció és a polimorfizmus fontos részei.',6,1),
('Az osztály egy sablon vagy tervrajz, amely alapján objektumokat hozunk létre. Az osztály definiálja az objektumok tulajdonságait és viselkedését.',7,1),
('Az objektumpéldány az osztály alapján létrejött konkrét példány, amely tartalmazza az osztály által definiált tulajdonságokat és viselkedéseket.',8,1),
('Az Object osztály az összes Java osztálynak az őse. Azaz minden Java osztály közvetve vagy közvetlenül örökli az Object osztályt.',9,1),
('Wrapper osztályok olyan osztályok, amelyek az alapvető adattípusokat (pl., int, double) objektumként kezelik. Segítenek az alapvető adattípusokat objektumként használni.',10,1),
('A "super" kulcsszó az ősosztály referenciáját jelöli, használható az ősosztály metódusainak vagy mezőinek hivatkozására a leszármazott osztályban.',11,1),
('Az "extends" kulcsszó az osztályok közötti öröklődést szolgálja, egy osztály kiterjeszthet egy másikat. Azaz a leszármazott osztály örökli az ősosztály tulajdonságait.',12,1),
('Az "implements" kulcsszó azt jelenti, hogy egy osztály vagy interfész implementálja egy másik interfész funkcionalitását. Azaz az osztály vagy interfész megvalósítja az interfész deklarált metódusait.',13,1),
('A POJO egy egyszerű, alapvető Java objektum, amely nem tartalmaz semmilyen különleges kötést vagy keretrendszert. A POJO-kat általában az adatok egyszerű reprezentálására használják.',14,1),
('Az egységbezárás azt jelenti, hogy egy osztály vagy modul csak a szükséges részleteket mutatja meg más osztályok vagy modulok számára, és elrejti a belső működését.',15,1),
('Az információrejtés azt jelenti, hogy egy osztály belső működését elrejtjük, és csak azokat a részleteket tesszük láthatóvá, amelyek szükségesek a külvilág számára.',16,1),
('Az öröklődés során egy osztály örökli egy másik osztály tulajdonságait és viselkedését. A leszármazott osztály hozzáfér az ősosztály tagjaihoz.',17,1),
('A polimorfizmus azt jelenti, hogy egy objektum különböző módon viselkedhet attól függően, hogy melyik osztályból származik.',18,1),
('A konstruktor egy speciális metódus az osztályban, amelyet az objektum létrehozásakor hívunk meg. A konstruktor inicializálja az objektum állapotát.',19,1),
('A konstruktor neve megegyezik az osztály nevével. Nem rendelkezik visszatérési típussal. Létezhet több konstruktor is az osztályban, de más paraméterezéssel.',20,1),
('A konstruktor túlterhelése azt jelenti, hogy az egy osztályban több konstruktor is lehet különböző paraméterekkel vagy paraméter nélkül.',21,1),
('A Java-ban nincs explicit destruktor, mert a Garbage Collector automatikusan gondoskodik a memóriakezelésről.',22,1),
('A Garbage Collector automatikusan megszünteti az elérhetetlen objektumokat, így felszabadítja a memóriát.',23,1),
('A láthatósági szintek meghatározzák, hogy egy adott osztálytag (változó, metódus) mennyire látható más osztályok számára. Private: csak az osztályban látható. Protected: az osztályban és annak leszármazottaiban látható. Public: mindenhol látható.',24,1),
('Nem látható mezőt, például private láthatóságút, csak az adott osztályban érhetjük el. Azaz egy másik osztályból nem férünk hozzá.',25,1),
('A "static" kulcsszó azt jelenti, hogy egy osztálytag (metódus vagy mező) osztályszintű, és nem példányszintű. Azaz az osztályhoz tartozik, nem a példányokhoz.',26,1),
('A "final" kulcsszó azt jelenti, hogy egy adott osztálytag (metódus, mező) értéke vagy implementációja nem változtatható meg, azaz konstans.',27,1),
('A "this" kulcsszó a jelenlegi objektumra hivatkozik, azaz azt az objektumot jelenti, amelyben a kulcsszót használjuk.',28,1),
('Egy mező egy osztálytag, amely tárol egy adatot vagy értéket. A mezők az osztály példányaiban vannak jelen, és az objektum állapotát reprezentálják.',29,1),
('Egy property egy speciális esetben egy osztályon belül, amely külön metódusok segítségével hozzáférést és beállítást tesz lehetővé egy privát mezőhöz.',30,1),
('Gettereket használunk egy privát mező értékének lekérdezésére, settereket pedig az érték beállítására. Ezek segítik az adatok elérését és manipulációját osztályon belül.',31,1),
('Konvenció szerint a konstruktorokat az osztály elején, a mezőket utána, majd a gettereket és settereket helyezzük el.',32,1),
('Java-ban a többszörös öröklődés nem támogatott osztályok esetén. Egy osztály csak egy másik osztályból származhat. Az interfészek azonban többszörös öröklődést támogatnak.',33,1),
('A Java SE (Java Standard Edition) a Java platform alapja, tartalmazza a Java nyelvet és a standard könyvtárat. Használata általános célú Java alkalmazások fejlesztésére szolgál.',34,1),
('A Java EE (Java Platform, Enterprise Edition) a Java platform egyik kiterjesztése, amelyet vállalati szintű alkalmazások fejlesztésére terveztek. Tartalmaz olyan technológiákat, mint a Servlets, JSP, EJB stb.',35,1),
('A JDK (Java Development Kit) tartalmazza a Java SE-t, valamint további fejlesztői eszközöket, például a fordítót (javac), a futtatókörnyezetet (java), a fejlesztői eszközöket és a könyvtárakat.',36,1),
('A JRE (Java Runtime Environment) tartalmazza a Java futtatókörnyezetet, amely szükséges a Java alkalmazások futtatásához. A JRE tartalmazza a Java virtuális gépet (JVM) és a Java könyvtárakat.',37,1),
('A JVM (Java Virtual Machine) az a virtuális gép, amely a Java byte kódokat futtatja. A JVM lefordítja a byte kódot a konkrét operációs rendszer és hardver számára.',38,1),
('A "javac" egy parancssori eszköz a JDK-ban, amely a Java forráskódokat fordítja le bytecode-ra (".class" fájlokra).',39,1),
('JIT (Just-In-Time) fordító a JVM-ben. Feladata a Java byte kódokat futtatási időben lefordítani a natív gépi kódra, ami a futtatási sebesség javítását szolgálja.',40,1),
('A Java forráskódokat a "javac" fordítóval fordítjuk le bytecode-ra, amelyet a JVM futtat.',41,1),
('A "java.io" csomag az I/O (Input/Output) műveleteket tartalmazza Java alkalmazások számára, például fájlkezelés, bemenet és kimenet kezelése.',42,1),
('A "java.sql" csomag a Java nyelv SQL adatbáziskezelő funkcióit támogatja. Az adatbázis-kezeléshez szükséges osztályokat és interfészeket tartalmazza.',43,1),
('A "java.awt" csomag (Abstract Window Toolkit) GUI komponenseket és eszközöket biztosít Java alkalmazásokhoz.',44,1),
('A "java.math" csomag matematikai műveletekhez szükséges osztályokat tartalmaz, például nagy számok kezelésére szolgáló "BigInteger" osztályt.',45,1),
('A "java.beans" csomag JavaBeans komponensek fejlesztéséhez szükséges eszközöket és osztályokat tartalmaz.',46,1),
('A "java.util" csomag Java általános használatú eszközöket tartalmaz, például kollekciókat (List, Set, Map), dátum- és időkezelést, random generátort stb.',47,1),
('A "Math" osztály Java-ban matematikai műveleteket biztosít. Fontosabb metódusai közé tartozik a "sqrt" (négyzetgyök), "abs" (abszolút érték), "pow" (hatványozás) stb.',48,1),
('Java-ban a primitív típusok közé tartoznak például az int, byte, short, long, float, double, char és boolean. Ezek a típusok közvetlenül tárolják az értékeket, nem objektumok.',49,1),
('Az összetett típusok olyan típusok, amelyek objektumokat vagy tömböket tartalmaznak. Ezek osztályok, interfészek vagy tömbök lehetnek.',50,1),
('Matematikai operátorok közé tartoznak például a + (összeadás), - (kivonás), * (szorzás), / (osztás), % (maradékos osztás) stb.',51,1),
('Relációs operátorok közé tartoznak például a == (egyenlőség), != (nem egyenlőség), < (kisebb), > (nagyobb), <= (kisebb vagy egyenlő), >= (nagyobb vagy egyenlő) stb.',52,1),
('Logikai operátorok közé tartoznak például a && (logikai ÉS), || (logikai VAGY), ! (logikai NEM) stb.',53,1),
('Prefix értéknövelés és csökkentés esetén az érték módosítása előtt növeljük vagy csökkentjük a változó értékét. Postfix esetén az érték módosítása után növeljük vagy csökkentjük.',54,1),
('A "Scanner" osztályt a Java 5-ben vezették be az egyszerű bemeneti adatok beolvasásához. A "BufferedReader" pedig hatékonyabb karakteres bemenet kezelésére szolgál.',55,1),
('Az adatok átalakítása a "String" típusba a "toString()" metódus segítségével történik.',56,1),
('A Java erősen típusos nyelv, ami azt jelenti, hogy a változóknak deklarációkor meg kell adni a típusukat, és típusellenőrzés történik a fordítási időben.',57,1),
('Változó létrehozásakor fontos szempontok a típus kiválasztása, az értékadás, a név megfelelő megválasztása, valamint a szükség szerinti inicializálás.',58,1),
('A switch-case szerkezetet használjuk, amikor egy változó értékét különböző esetekre kell vizsgálni, és minden esetben más kódblokkot hajtunk végre.',59,1),
('A "default" ágat a switch-case szerkezetben akkor használjuk, ha egyik előző eset sem teljesül. Ez az ág opcionális.',60,1),
('A "break" utasítás a switch-case szerkezetben használható arra, hogy kilépjen a szerkezetből, és ne folytassa a további esetek kiértékelését.',61,1),
('A "break" utasítás a ciklusok és switch-case szerkezetek esetében használható a kilépésre, míg a "continue" az aktuális iteráció elhagyására szolgál.',62,1),
('A Java-ban használt ciklusok közé tartoznak a "for", "while" és "do-while" ciklusok.',63,1),
('Az elágazások Java-ban olyan szerkezetek, mint az "if", "else if", "else", "switch-case", amelyek segítségével döntéseket hozhatunk a kódban.',64,1),
('A "while" és "do-while" ciklusok közötti különbség abban rejlik, hogy a "while" először ellenőrzi a feltételt, majd hajtja végre a kódot, míg a "do-while" legalább egyszer végrehajtja a kódot, és csak utána ellenőrzi a feltételt.',65,1),
('A programozási tételek olyan algoritmusok, amelyek gyakran előforduló problémákat oldanak meg, például keresés, rendezés, szűrés stb.',66,1),
('A "void" kulcsszó használata a Java-ban azt jelzi, hogy egy metódusnak nincs visszatérési értéke.',67,1),
('A formális paraméterek a metódus fejlécében találhatók, és azok a változók, amelyek a metóduson belül használhatók. Az aktuális paraméterek a metódus hívásakor megadott értékek.',68,1),
('A metódus túlterhelése lehetővé teszi, hogy azonos nevű, de különböző paraméterekkel rendelkező metódusokat hozzunk létre egy osztályban.',69,1),
('A metódus szignatúrája a metódus nevét és a formális paraméterek típusát tartalmazza. A visszatérési típus és a metódus neve önmagában nem szignatúra.',70,1),
('A metódus deklarációja meghatározza a metódus nevét, visszatérési típusát, formális paramétereit és a kódblokkot. A metódus hívása során az aktuális paraméterekkel átadjuk az értékeket a metódusnak.',71,1),
('A tömbök olyan adatszerkezetek, amelyek lehetővé teszik az azonos típusú elemek csoportosítását. A tömbök mérete fix, és deklarációkor meg kell adni.',72,1),
('A tömb elemeinek hivatkozása indexszel történik, pl.: tomb[0] az első elemre utal.',73,1),
('Tömbkezelő metódusok olyan műveletek, amelyek segítségével könnyedén manipulálhatjuk a tömb elemeit, például keresés, rendezés stb.',74,1),
('Néhány példa rendező algoritmusra: buborékrendezés, kiválasztásos rendezés, beszúró rendezés, gyorsrendezés, összefésüléses rendezés.',75,1),
('A rendező algoritmusok jóságát meghatározza a futási idő, a memóriahasználat és a stabilitás.',76,1),
('Fájl létrehozása során a "File" osztály segítségével megadott néven hozunk létre egy új fájlt. Ezt követően a "FileOutputStream" vagy "BufferedWriter" osztályok segítségével írhatunk a fájlba.',77,1),
('A fájl lezárása fontos, mert ez felszabadítja a használt erőforrásokat és biztosítja, hogy más programok is hozzáférhessenek a fájlhoz.',78,1),
('Fájlból való olvasás során a "FileInputStream" vagy "BufferedReader" osztályok segítségével hozzunk létre egy olvasó objektumot, majd az olvasó objektum segítségével olvassuk be a fájl tartalmát.',79,1),
('Java-ban nincsenek explicit pointerek, mint például a C++-ban. Az objektumok referenciával hivatkozhatók, de nincs lehetőség pointer aritmetikára vagy közvetlen memóriacímzésre.',80,1),
('A split függvényt String típusú objektumokon lehet használni, és segítségével feloszthatjuk a szöveget egy megadott elválasztó karakter alapján. A visszatérési értéke egy tömb, amelyben az elválasztott részek találhatók.',81,1),
('A "split" metódust használhatjuk, amely egy szöveget egy megadott elválasztó karakter vagy reguláris kifejezés alapján darabol fel.',82,1),
('A "concat" metódust használhatjuk, amely két szöveg összefűzésére szolgál. Alternatívaként a "+" operátort is használhatjuk a szövegek összefűzésére.',83,1),
('A "format" metódust használhatjuk, amely egy formázott szöveget hoz létre a megadott minta és értékek alapján.',84,1),
('A "substring" metódust használhatjuk, amely egy szöveg részét kiválasztja az adott indexek között.',85,1),
('A "contains" metódust használhatjuk, amely megvizsgálja, tartalmazza-e a szöveg egy adott karakterláncot vagy karaktert.',86,1),
('Az "equals" metódust használhatjuk, amely megvizsgálja, hogy két szöveg megegyezik-e.',87,1),
('A "replace" metódust használhatjuk, amely kicseréli egy szövegben az egyik karakterláncot egy másikkal.',88,1),
('A "indexOf" metódust használhatjuk, amely megkeresi egy adott karakterlánc vagy karakter első előfordulásának indexét a szövegben.',89,1),
('Az java.time package-ben található LocalDate, LocalTime, LocalDateTime, ZonedDateTime osztályokat érdemes használni dátumkezelésre.',90,1),
('A Java 11-ben a Date, Calendar, DateFormat, SimpleDateFormat osztályok már elavultak (deprecated) és nem ajánlott használni őket dátum és időkezelésre.',91,1),
('A dátumok összehasonlítására a compareTo vagy az isBefore, isAfter, isEqual metódusok használhatók. A compareTo negatív értéket ad vissza, ha az első dátum korábbi, pozitív értéket, ha későbbi, és 0-t, ha azonosak.',92,1),
('1. Faktoriális számítás. 2. Fibonacci sorozat generálása. 3. Binomiális együttható számítása. 4. Hanoi tornyai probléma. 5. Egyszerű számok keresése.',93,1),
('1. A rekurzív algoritmusok hívják önmagukat egy adott probléma részfeladatának megoldására. 2. Minden rekurzív algoritmusnak van egy alapszállása (base case), amely megszakítja a rekurziót. 3. A rekurzív algoritmusok általában egyszerűbben kifejezhetők és olvashatók, mint az iteratív megoldások.',94,1),
('A Java LTS (Long-Term Support) verziói a következők: Java 8, Java 11, Java 17.',95,1),
('A Java 8 újdonságai közé tartozik a lambda kifejezések bevezetése, a funkcionális interfészek, a Stream API, az új java.time csomag a dátum és idő kezeléshez, valamint a default és static metódusok interfészekben.',96,1),
('A Java 11 újdonságai közé tartozik a var kulcsszó bevezetése, a HTTP/2 támogatás a HttpClient-ban, az új java.nio.file metódusok, valamint a Local-Variable Syntax for Lambda Parameters a lambda kifejezésekhez.',97,1),
('A Java 17 újdonságai közé tartozik a Sealed Classes, a Pattern Matching for switch, a Foreign Function & Memory API (Incubator), a Elastic Metaspace és a New macOS Rendering Pipeline.',98,1),
('A JCF egy előre elkészített gyűjtemény (collection) osztályok és interfészek gyűjteménye, amelyek könnyen használhatók és optimalizáltak. A JCF segítségével könnyen kezelhetjük és manipulálhatjuk az adatokat különböző szerkezetekben, mint például listák, halmazok vagy térképek.',99,1),
('Az alábbi néhány fontos interfész és azok implementációi tartoznak a JCF-hez: 1. List: ArrayList, LinkedList, Vector stb. 2. Set: HashSet, LinkedHashSet, TreeSet stb. 3. Map: HashMap, LinkedHashMap, TreeMap stb.',100,1),
('A List interfész olyan kollekciókat reprezentál, amelyek sorrendben tartják az elemeket és indexszel hozzáférhetők. Jellemzői: 1. Engedélyezi a duplikált elemeket. 2. Indexszel hivatkozhatók az elemek. 3. Az implementációk közé tartozik az ArrayList, LinkedList, Vector.',101,1),
('A Set interfész olyan kollekciókat reprezentál, amelyek nem tartalmaznak duplikált elemeket. Jellemzői: 1. Nem tartalmazza a duplikált elemeket. 2. Nincs definiált sorrendje. 3. Az implementációk közé tartozik a HashSet, LinkedHashSet, TreeSet.',102,1),
('A Map interfész olyan kollekciókat reprezentál, amelyek kulcs-érték párokat tartalmaznak. Jellemzői: 1. Minden kulcs egyedi. 2. A kulcsokhoz hozzárendelhető értékek. 3. Az implementációk közé tartozik a HashMap, LinkedHashMap, TreeMap.',103,1),
('A List interfész implementációi közé tartoznak például az ArrayList, LinkedList, Vector osztályok.',104,1),
('A Set interfész implementációi közé tartoznak például a HashSet, LinkedHashSet, TreeSet osztályok.',105,1),
('A Map interfész implementációi közé tartoznak például a HashMap, LinkedHashMap, TreeMap osztályok.',106,1),
('Az ArrayList osztály egy dinamikusan növelhető tömböt reprezentál. Jellemzői: 1. Gyors hozzáférés az elemekhez index alapján. 2. Dinamikus méret, automatikus növekedés. 3. Engedélyezi a duplikált elemeket.',107,1),
('A LinkedList osztály egy kétirányú láncolt listát reprezentál. Jellemzői: 1. Beszúrás és törlés hatékony a listában. 2. Kétirányú láncolt lista struktúra. 3. Engedélyezi a duplikált elemeket.',108,1),
('A Stack osztály egy vermet (stack) reprezentál, ahol az utolsó bejövő elem az első, amit kivehetünk (LIFO). Jellemzői: 1. Last In, First Out (LIFO) működés. 2. Push (betesz) és Pop (kivesz) műveletek. 3. Implementálja a Vector osztályt.',109,1),
('A Hashtable osztály egy kulcs-érték párokat tartalmazó gyűjteményt reprezentál. Jellemzői: 1. Kulcsok és értékek nem lehetnek null. 2. Szinkronizált, thread-safe implementáció. 3. Elavult, érdemes inkább a HashMap használata.',110,1),
('Az ArrayList osztály remove(int index) metódusával lehet index alapján eltávolítani egy elemet.',111,1),
('Az Collections osztály sort metódusával lehet csökkenő sorrendbe rendezni egy listát. Például: Collections.sort(list, Collections.reverseOrder()).',112,1),
('Az Collections osztály sort metódusával lehet növekvő sorrendbe rendezni egy listát. Például: Collections.sort(list).',113,1),
('Az ArrayList dinamikusan növelhető, míg a sima tömb statikus mérettel rendelkezik. Az ArrayList kezelő metódusokat biztosít az elemek hozzáadásához, eltávolításához, kereséséhez, míg a sima tömbhöz ezeket a funkcionalitásokat manuálisan kell implementálni. Az ArrayList lehetővé teszi a generikus típusok használatát, míg a sima tömb csak egy adott típusú elemeket tartalmazhat.',114,1),
('Néhány ArrayList-hez használható metódus: 1. add(E element): Hozzáad egy elemet az ArrayList-hez. 2. remove(int index): Eltávolítja az adott indexű elemet. 3. get(int index): Visszaadja az adott indexű elemet. 4. size(): Megadja az ArrayList méretét. 5. clear(): Törli az összes elemet az ArrayList-ből.',115,1),
('Interface-ek: 1. Csak absztrakt (nem implementált) metódusokat tartalmazhatnak. 2. Egy osztály több interface-t is implementálhat. 3. Nem tartalmaznak adattagokat (mezőket). Absztrakt osztályok: 1. Tartalmazhatnak implementált és absztrakt metódusokat is. 2. Egy osztály csak egy absztrakt osztályt terjeszthet ki. 3. Tartalmazhatnak adattagokat és konstruktort is.',116,1),
('A Hashtable osztály a Map interfészt implementálja, és az entrySet() metódust használhatjuk az elemek iterálására. Például: java for (Map.Entry<K, V> entry : hashtable.entrySet()) { // elemek kezelése }',117,1),
('Felhasználások: 1. Kontraktusok definiálása: Az interface-ek meghatározzák azokat a metódusokat, amelyeket az implementáló osztálynak el kell látnia. 2. Többszörös öröklődés szimulálása: Az egy osztály csak egyetlen osztályt terjeszthet ki, de több interface-t is implementálhat. 3. Kódújrafelhasználás: Az interface-ek lehetővé teszik a kódújrafelhasználást, mivel egy interfészt több osztály is implementálhat. Működés: Az interface egy olyan szerkezet, amely csak absztrakt (nem implementált) metódusokat, konstansokat és default metódusokat tartalmaz. Az implementáló osztályoknak meg kell valósítaniuk az összes interfészben definiált metódust.',118,1),
('Előnyök: 1. Kódújrafelhasználás: Az egyes rétegek elkülönülése lehetővé teszi a kódújrafelhasználást és a könnyebb karbantarthatóságot. 2. Moduláris fejlesztés: A rétegezés lehetővé teszi a moduláris fejlesztést, ahol az egyes rétegek függetlenül fejleszthetők és tesztelhetők. 3. Könnyebb karbantarthatóság: Az alkalmazás részeinek elkülönítése megkönnyíti a hibakeresést és a fejlesztést. Rétegek: 1. Felhasználói interfész (UI) réteg: A felhasználóval való interakcióért felelős réteg. 2. Üzleti logika (Business Logic) réteg: Az üzleti folyamatok és szabályok implementációja. 3. Adatelérés (Data Access) réteg: Az adatbázishoz vagy más adatforrásokhoz való hozzáférés.',119,1),
('Felhasználások: 1. Webfejlesztés: Az MVC tervezési mintát gyakran alkalmazzák webalkalmazások tervezésére, ahol az adatok, a megjelenítés és a vezérlés külön rétegekben helyezkednek el. 2. Grafikus felhasználói felületek: Az MVC-t gyakran használják grafikus felhasználói felületek fejlesztésére, ahol a modell reprezentálja az adatokat, a nézet megjeleníti azokat, a vezérlő pedig a felhasználói interakciót kezeli. Működés: 1. Modell (Model): Az alkalmazás adatrétegét reprezentálja. Tartalmazza az adatokat, az adatok manipulálására szolgáló logikát és az eseményeket. 2. Nézet (View): Az alkalmazás felhasználói felületét reprezentálja. Megjeleníti a modell adatait és elküldi a felhasználói interakciókat a vezérlőnek. 3. Vezérlő (Controller): Az alkalmazás irányítását végzi. Fogadja a felhasználói interakciókat a nézettől, feldolgozza azokat, és frissíti a modellt vagy a nézetet ennek megfelelően.',120,1),
('Model réteg: Az MVC tervezési mintában a Model réteg az alkalmazás adatrétegét reprezentálja. Feladatai: 1. Adatok kezelése: Tartalmazza az alkalmazás adatokat és azok manipulálására szolgáló logikát. 2. Események kezelése: Továbbítja az eseményeket a Controller réteg felé. 3. Frissítések kiküldése: Értesíti a nézetet az adatok változásairól, hogy azok megfelelően frissíthessék magukat.',121,1),
('View réteg: Az MVC tervezési mintában a View réteg az alkalmazás felhasználói felületét reprezentálja. Feladatai: 1. Adatok megjelenítése: Megjeleníti a Model rétegben található adatokat. 2. Felhasználói interakciók továbbítása: Továbbítja a felhasználói interakciókat a Controller réteg felé. 3. Frissítések kérésének továbbítása: Kéri a Model rétegtől a frissítéseket adatainkról.',122,1),
('Controller réteg: Az MVC tervezési mintában a Controller réteg az alkalmazás irányítását végzi. Feladatai: 1. Felhasználói interakciók kezelése: Fogadja és feldolgozza a felhasználói interakciókat a View rétegtől. 2. Adatmanipuláció kérésének továbbítása: Továbbítja a Model réteg felé az adatmanipuláció kéréseket. 3. Nézet frissítése: Frissíti a View réteget az adatok vagy a modell változásai után.',123,1),
('MVP (Model-View-Presenter): 1. Model: Az alkalmazás adatrétegét reprezentálja, tartalmazza az adatokat és azok manipulálására szolgáló logikát. 2. View: Az alkalmazás felhasználói felületét reprezentálja, megjeleníti a Modelben található adatokat. 3. Presenter: Az alkalmazás irányítását végzi, kezeli a felhasználói interakciókat és továbbítja azokat a Model felé. A Presenter frissíti a View-t az adatok változásai után.',124,1),
('MVVM (Model-View-ViewModel): 1. Model: Az alkalmazás adatrétegét reprezentálja, tartalmazza az adatokat és azok manipulálására szolgáló logikát. 2. View: Az alkalmazás felhasználói felületét reprezentálja, megjeleníti a Modelben található adatokat. 3. ViewModel: Az alkalmazás logikáját tartalmazza, kezeli a felhasználói interakciókat és frissíti a Modelt és a Viewt. A ViewModel közvetlenül kapcsolódik a View-hoz, de nem ismeri a View-t.',125,1),
('DTO (Data Transfer Object): 1. Adatok átvitele: A DTO-kat használjuk az adatok átvitelére az alkalmazás rétegei között. 2. Interfész definíció: A DTO-k meghatározzák, milyen adatokat lehet átvinni a rétegek között, és ezáltal szolgálnak interfész szerepében. 3. Performance optimalizáció: A DTO-k lehetővé teszik csak a szükséges adatok átvitelét, ezáltal optimalizálva az alkalmazás teljesítményét.',126,1),
('DAO (Data Access Object): 1. Adatelérés szeparálása: A DAO réteget használjuk az adatelérés logikájának elkülönítésére a többi rétegtől. 2. Adatbáziskapcsolat kezelése: A DAO réteg felelős az adatbáziskapcsolat létrehozásáért és kezeléséért. 3. Üzleti logika szétválasztása: Segít az üzleti logikától való szétválasztásban, így az könnyen karbantartható és tesztelhető.',127,1),
('Service réteg: 1. Üzleti logika: A service réteget használjuk az alkalmazás üzleti logikájának elhelyezésére és kezelésére. 2. Tranzakciókezelés: A service réteg felelős a tranzakciók kezeléséért, biztosítva ezzel az adatintegritást. 3. Kliens interfész: A service réteget használjuk az alkalmazás kliens interfészének biztosítására, ahol a kliensek hívhatják a különböző üzleti szolgáltatásokat.',128,1),
('Repository réteg: 1. Adattárolás és lekérdezés: A repository réteget használjuk az adatok tárolására és lekérdezésére az adatbázissal történő kommunikációért felelős módon. 2. Adatelérés absztrakció: Az adatelérési logika absztrakcióját nyújtja az üzleti logika felé, így az nem kell foglalkozzon az adatbázissal való konkrét kommunikációval. 3. Keresési és mentési műveletek: A repository réteget használjuk a keresési és mentési műveletek biztosítására az alkalmazáson belül.',129,1),
('A reguláris kifejezések kezelésére az java.util.regex csomagban található osztályokat használhatjuk, például a Pattern és Matcher osztályokat.',130,1),
('Speciális karakterek és beállítások: 1. Metakarakterek: Olyan karakterek, amelyek speciális jelentéssel bírnak a reguláris kifejezésekben, például a . vagy a *. 2. Kvantifikátorok: Meghatározzák a keresett karakterek ismétlődését, például a * vagy a +. 3. Zárójelek: Csoportosításra szolgálnak, például a ( ). 4. Karakterosztályok: Lehetőséget adnak karakterek vagy karaktertartományok kijelölésére, például a [ ]. 5. Escapelt karakterek: A metakarakterek előtti \ karakterrel történő lekezelése.',131,1),
('Kivételek: 1. Hibák jelzése: A kivételek az alkalmazás futása során fellépő hibákat jelzik, például osztály nem található vagy null értékre hivatkozás. 2. Hibakezelés: Segítenek a hibák kezelésében, hogy az alkalmazás ne álljon le, hanem graceful módon tudjon reagálni a hibákra. 3. Hibainformáció átvitele: Tartalmazhatnak információkat a hibáról, segítve a hibakeresést.',132,1),
('Néhány példa kivételkezelő osztályra: 1. NullPointerException: Null értékre hivatkozás esetén keletkezik. 2. ArrayIndexOutOfBoundsException: Érvénytelen tömbindex hivatkozás esetén keletkezik. 3. ArithmeticException: Érvénytelen aritmetikai művelet esetén keletkezik. 4. FileNotFoundException: Fájl nem található esetén keletkezik. 5. IOException: Általános bemeneti/kimeneti hiba esetén keletkezik.',133,1),
('Saját kivételkezelő osztály létrehozása: 1. Az Exception vagy egy származtatott kivételkezelő osztályból származtatjuk a saját osztályunkat. 2. Meghatározzuk az egyedi konstruktort és lehetőség szerint a hibainformációkat tartalmazó mezőket. 3. Az egyedi konstruktorban hívjuk meg az ősosztály konstruktorát, például super(message).',134,1),
('Checked kivételek: 1. Kötelezően kezelendőek: A fordító ellenőrzi, hogy a checked kivételeket kezelik-e a kódban, vagy deklarálták-e a metódust dobóként. 2. Exception osztályból származnak, kivéve a RuntimeException és leszármazottai. Unchecked kivételek: 1. Nem kötelezőek kezelni: A fordító nem ellenőrzi, hogy az unchecked kivételeket kezelik-e a kódban. 2. Általában a RuntimeException és leszármazottai.',135,1),
('try-catch szerkezet felépítése: 1. try: Azon kódblokk, amelyben hibák lehetnek, és amit monitorozni kell. 2. catch: Azon kódblokk, amely a kivételt kezeli, ha a try blokkban hiba történik. 3. Kivételek típusainak megadása: A catch blokkban meg kell adni, milyen típusú kivételt kezelünk. 4. finally (opcionális): Azon kódblokk, amely mindenképpen lefut, függetlenül attól, hogy a try blokkban hiba történt-e vagy sem.',136,1),
('finally kulcsszó: A finally blokk azon kódrészlet, amely mindenképpen lefut, függetlenül attól, hogy a try blokkban hiba történt-e vagy sem. A finally blokkban olyan kód helyezhető el, amelynek mindenképpen le kell futnia, például erőforrások felszabadítása vagy zárása.',137,1),
('Predicate-ek: 1. Logikai feltételek definiálása: A Predicate interfész logikai feltételeket definiál egy bemeneti objektumra. 2. Szűrés: A Predicate-eket használhatjuk kollekciók szűrésére, például egy listában csak azokat az elemeket tartalmazni, amelyek megfelelnek a feltételnek. 3. Összetett feltételek: Több Predicate összekapcsolásával összetett logikai feltételeket is definiálhatunk.',138,1),
('Functional Interface-ek: 1. Lambda kifejezések: A functional interface-ek lehetővé teszik a lambda kifejezések használatát. 2. Egyszerűsített interfész: Egyetlen absztrakt metódussal rendelkező interfész. 3. Funkcionális programozás: A functional interface-ek lehetővé teszik a funkcionális programozási stílus használatát a Java-ban.',139,1),
('Lambda kifejezések előnyei: 1. Rövidebb kód: Leegyszerűsíti és lerövidíti a kódot. 2. Olvashatóság: Segíti a kódban való olvashatóságot. 3. Funkcionális programozás: Lehetővé teszi a funkcionális programozási stílus használatát. 4. Többszálú programozás: Könnyen használható többszálú programozási környezetben is.',140,1),
('Lambda kifejezés szintakszisa: (paraméterek) -> kifejezés Például: () -> System.out.println("Hello, World!");',141,1),
('StreamAPI használata: 1. Adatsorok kezelése: A Stream lehetővé teszi adatsorok kezelését, például kollekciók elemzését. 2. Funkcionális programozás: A Stream segítségével funkcionális programozási stílusban dolgozhatunk. 3. Párhuzamos végrehajtás: Többszálú és párhuzamos végrehajtást támogat.',142,1),
('Stream API szintaxisok: a. Iteráció: stream.forEach(element -> System.out.println(element)); b. Szűrés: stream.filter(element -> element > 5) c. Csoportosítás: stream.collect(Collectors.groupingBy(Function.identity())) d. Aggregált műveletek: stream.sum(), stream.average(), stb. e. Kimeneti darabszám korlátozás: stream.limit(10)',143,1),
('Thread osztály: A Thread osztály segítségével hozhatunk létre szálakat a Java-ban. Például: Thread myThread = new Thread(() -> System.out.println("Hello from thread!"));',144,1),
('Többszálú alkalmazás készítése: 1. Thread osztály: Használjuk a Thread osztályt szálak létrehozásához. 2. Runnable interfész: Implementáljuk a Runnable interfészt és adjuk át a példányt a Thread konstruktorának. 3. Executor framework: Használjuk az ExecutorService-t a szálak menedzseléséhez.',145,1),
('synchronized kulcsszó: A synchronized kulcsszó segítségével biztosíthatjuk, hogy egyetlen szál sem zavarja meg a kritikus szakaszt (critical section). Ez a kulcsszó alkalmazható metódusokon és blokkokon is.',146,1),
('start metódus: A start metódus elindítja a szálat, és a run metódust a saját szálán futtatja.',147,1),
('join metódus: A join metódus lehetővé teszi egy szálnak, hogy várjon egy másik szálra, mielőtt folytatná a végrehajtást.',148,1),
('sleep metódus: A sleep metódus szünetelteti a szálat egy megadott időtartamig.',149,1),
('Többszálú alkalmazások problémái: 1. Versenyhelyzetek: Két vagy több szál egyidejűleg módosíthatja az adatokat. 2. Elakadások: Szálak végtelenül várakozhatnak egymásra. 3. Adatverseny: Két vagy több szál egyszerre próbál hozzáférni az erőforrásokhoz. 4. Teljesítményproblémák: Túl sok szál hozhat létre túl sok konkurenciát.',150,1),
('URL osztály: Az URL osztály segítségével hivatkozhatunk és manipulálhatunk uniform resource locatorokat. Használható weboldalak, fájlok és más internetes erőforrások címének kezelésére.',151,1),
('Különbség: XML (Extensible Markup Language) és JSON (JavaScript Object Notation) mindkettő szöveg alapú adatcserélő formátum, de különböznek a struktúrájukban. XML tagek és attribútumok felhasználásával hierarchikus struktúrát alkot, míg JSON egy könnyen olvasható adatformátum, ami a kulcs-érték párokat használja. Előnyök/hátrányok: XML előnyei: Emberi olvashatóság, sémával validálható, támogatja az attribútumokat. Hátrányai: Több karakter, nehezen kezelhető. JSON előnyei: Egyszerű és rövid, könnyen olvasható, könnyen kezelhető JavaScriptben. Hátrányai: Emberi olvashatóság csökken, attribútumokat nehezebb kezelni.',152,1),
('Gson osztály: A Gson osztály a Google által fejlesztett Java könyvtár, amely lehetővé teszi JSON objektumok és Java objektumok közötti átalakítást. JSON szöveget alakíthatunk át Java objektummá (fromJson metódus), illetve Java objektumot JSON szöveggé (toJson metódus).',153,1),
('XML feldolgozás osztályai és metódusai: 1. DocumentBuilder osztály: XML dokumentum létrehozása. 2. Document osztály: Az XML dokumentum reprezentálása. 3. Element osztály: XML elemek reprezentálása. 4. NodeList osztály: Node-ok kollekciója. 5. XPath osztály: XPath kifejezések kezelése.',154,1),
('JSON feldolgozás osztályai és metódusai: 1. JSONObject osztály: JSON objektumok reprezentálása. 2. JSONArray osztály: JSON tömbök reprezentálása. 3. JSONParser osztály: JSON szöveg elemzése. 4. JSONWriter osztály: JSON szöveg írása.',155,1),
('Timer és TimerTask: A Timer osztályt használhatjuk arra, hogy időzített feladatokat hajtsunk végre. A TimerTask absztrakt osztályból származtatott osztályokat használhatunk, amelyeket a Timer ütemez be és hajt végre az előre megadott időközönként.',156,1),
('Reflection API: 1. Class osztály: Osztályokkal kapcsolatos információk lekérdezése. 2. Method osztály: Metódusokkal kapcsolatos információk lekérdezése. 3. Field osztály: Mezőkkel kapcsolatos információk lekérdezése. 4. Constructor osztály: Konstruktorokkal kapcsolatos információk lekérdezése. 5. InvocationTargetException kivétel: Metódus hívás során fellépő kivétel.',157,1),
('Legfontosabb osztályok: 1. Connection: Adatbázis kapcsolat kezelése. 2. Statement: SQL utasítások végrehajtása. 3. ResultSet: Adatok eredményhalmaza. 4. DriverManager: JDBC driverek kezelése.',158,1),
('Connection osztály: Az Connection osztályt használhatjuk adatbázis kapcsolat létrehozására, kezelésére és bezárására. Az autocommit beállítás és tranzakciók kezelése is ezen keresztül történik.',159,1),
('Statement osztály: A Statement osztály segítségével SQL utasításokat hajthatunk végre az adatbázison keresztül. Lehetőséget biztosít egyszerű (plain) és előkészített (prepared) utasítások végrehajtására is.',160,1),
('DriverManager osztály: A DriverManager osztály felelős a JDBC driverek regisztrálásáért és azok kezeléséért. Az adatbázis-illesztőprogramok elérhetőségét biztosítja.',161,1),
('SQLException osztály: Az SQLException osztály az SQL kivételeket reprezentálja. Az adatbázis műveletek során keletkező hibák kezelésére használható.',162,1),
('Prepared Statement előnyei: 1. Teljesítmény: Az SQL utasítás előkészítése egyszer történik, és többször használható, így hatékonyabb, mint az egyszerű Statement. 2. Biztonság: A Prepared Statement automatikusan kezeli az SQL injection támadásokat, mert a paramétereket biztonságosan átadja. 3. Olvashatóság: A Prepared Statementek olvashatóbbak, mert a paraméterek nevekkel helyettesíthetők.',163,1),
('ResultSet használata: A ResultSet objektumot használjuk az adatbázisból lekért eredményhalmaz kezelésére. A ResultSet tartalmazza az eredményhalmaz sorait, amelyeket a program feldolgozhat.',164,1),
('ResultSet indexek használata: A ResultSet indexeivel történő hivatkozásnál a getInt(1), getString(2), stb. metódusokat használjuk, ahol a számok a kiválasztott oszlopok indexeit jelölik.',165,1),
('JPA (Java Persistence API): A JPA egy Java EE technológia, amely lehetővé teszi az objektum-relációs leképezés (ORM) alkalmazását. A JPA segítségével Java objektumokat lehet tárolni és lekérdezni az adatbázisból, miközben az objektumok és az adatbázis közötti kapcsolatot automatikusan kezeli. A JPA általában az Entity osztályokat használja, amelyek az adatbázistáblákat reprezentálják.',166,1),
('Hibernate működése: A Hibernate egy ORM keretrendszer, amely az objektumokat és az adatbázist összekapcsolja. A Hibernate segítségével a Java objektumokat tárolhatjuk és lekérdezhetjük az adatbázisból anélkül, hogy részletes SQL utasításokat kellene írnunk. A Hibernate automatikusan létrehozza a szükséges SQL utasításokat az objektumok tárolásához, és az adatbázis és az objektumok közötti kapcsolatot kezeli.',167,1),
('Esemény-vezérelt alkalmazás: Az esemény-vezérelt alkalmazás olyan program, amely az eseményekre reagál, és azoktól vezérelve működik. Az események lehetnek felhasználói interakciók, rendszeresemények vagy más események, amelyek befolyásolhatják az alkalmazás állapotát vagy működését.',168,1),
('Eseménytípusok: 1. Felhasználói interakciók: Gombok lenyomása, egérkattintás, billentyűleütés stb. 2. Rendszeresemények: Időzítő lejár, adatfájl érkezik stb. 3. Egyéb események: Hálózati események, érzékelők állapotváltozása stb.',169,1),
('Esemény csoportosítás: 1. Felhasználói események: Kattintás, billentyűleütés stb. 2. Rendszeresemények: Időzítő lejár, adatfájl érkezik stb. 3. Egyéb események: Hálózati események, érzékelők állapotváltozása stb.',170,1),
('Java GUI toolkit választása: A választás attól függ, hogy milyen követelményeknek kell megfelelni. 1. Swing: Jól testreszabható, támogatja a look-and-feel változtatást, tiszta Java-komponensek. 2. AWT: Könnyű használni, alacsonyabb szintű, operációs rendszerfüggő kinézet. 3. JavaFX: Modern, könnyen testreszabható, széles körű támogatás.',171,1),
('Look-and-Feel támogatás: A Swing támogatja a look-and-feel funkciót, ami azt jelenti, hogy az alkalmazás megjelenése és stílusa platformfüggetlenül testreszabható. Például a Windows-on más lehet a kinézet, mint a Linux-on vagy macOS-en.',172,1),
('Swing-es grafikus felület létrehozása: 1. Komponensek létrehozása: Gombok, címkék, szövegmezők stb. 2. Komponensek elhelyezése: Panel, keret, elrendezési menedzser használata. 3. Események kezelése: Eseménykezelők hozzáadása a komponensekhez. 4. Ablak megjelenítése: Az alkalmazás ablakának megjelenítése.',173,1),
('Swing: JOptionPane komponens használható felugró ablak készítésére.',174,1),
('Swing: JCheckBox komponens használható pipálható mező létrehozására.',175,1),
('Swing: JRadioButton komponens használható rádió gomb létrehozására.',176,1),
('Swing: JComboBox komponens használható legördülő menü létrehozására.',177,1),
('Swing: JLabel komponens használható címke létrehozására.',178,1),
('Swing: JTextField komponens használható szöveges beviteli mező létrehozására.',179,1),
('Swing: JPasswordField komponens használható jelszó típusú beviteli mező létrehozására.',180,1),
('Swing: JButton komponens használható gomb létrehozására.',181,1),
('Swing: JPanel komponens használható tároló (panel) létrehozására.',182,1),
('Swing: ButtonGroup komponens használható rádió gombok csoportosítására.',183,1),
('JavaFX-es grafikus felület létrehozása: 1. Fő alkalmazáskomponens (Scene): A Scene osztály segítségével létrehozhatjuk az alkalmazás fő komponensét. 2. Fő ablak (Stage): A Stage osztály reprezentálja az alkalmazás fő ablakát. 3. Komponensek hozzáadása: Az add vagy getChildren().add metódusokkal hozzáadhatjuk a kívánt komponenseket a fő komponenshez.',184,1),
('Swing layout-ok: 1. FlowLayout: Elemek egymás után, soronként. 2. BorderLayout: Elemek északi, déli, keleti, nyugati és középső régiókban. 3. GridLayout: Elemek rácsban, oszlopok és sorok szerint. 4. BoxLayout: Elemek egymás mellett, vízszintesen vagy függőlegesen. 5. CardLayout: Elemek lapokként, csak egy lap látható egyszerre.',185,1),
('JavaFX layout-ok: 1. VBox és HBox: Elemek függőlegesen (VBox) vagy vízszintesen (HBox) egymás után. 2. BorderPane: Elemek északi, déli, keleti, nyugati és középső régiókban. 3. GridPane: Elemek rácsban, oszlopok és sorok szerint. 4. StackPane: Elemek egymásra rétegzése. 5. AnchorPane: Elemek rögzítése az ablak sarkaihoz vagy közepéhez.',186,1),
('Láthatóság beállítása: 1. Swing: setVisible(true/false) metódus használható a láthatóság beállítására. 2. JavaFX: setVisible(true/false) metódus használható a láthatóság beállítására.',187,1),
('Elérhetőség beállítása: 1. Swing: setEnabled(true/false) metódus használható az elérhetőség beállítására. 2. JavaFX: setDisable(true/false) metódus használható az elérhetőség beállítására.',188,1),
('Maven előnyei: 1. Függőségek kezelése: Automatikus függőségkezelés és letöltés a Maven Central Repository-ból. 2. Életciklus kezelés: Automatikus projektéletciklus-kezelés és építés. 3. Konvenciók szerinti konfiguráció: Az alapvető beállításokat a projekt struktúrájából kiindulva konvenciók alapján állítja be.',189,1),
('pom.xml célja: A pom.xml (Project Object Model) fájl a Maven projekt konfigurációs fájlja, amely tartalmazza a projekt leírását, függőségeit és építési konfigurációját.',190,1),
('Maven projekt életciklusa: 1. validate: Projekt ellenőrzése. 2. compile: Forráskód fordítása. 3. test: Tesztek futtatása. 4. package: Artifaktok csomagolása. 5. verify: Az építési eredmények ellenőrzése. 6. install: Az artifaktok a helyi Maven Repository-be telepítése. 7. deploy: Az artifaktok távoli tárolóba telepítése.',191,1),
('Műveletek leírása: 1. validate: A projekt ellenőrzése. 2. compile: A forráskód fordítása. 3. test: A tesztek futtatása. 4. package: Az artifaktok csomagolása. 5. verify: Az építési eredmények ellenőrzése. 6. install: Az artifaktok telepítése a helyi Maven Repository-be. 7. deploy: Az artifaktok távoli tárolóba telepítése.',192,1),
('Függőség hozzáadása: A pom.xml fájlban a <dependencies> szekcióban adhatunk hozzá függőségeket. Példa: xml <dependencies> <dependency> <groupId>group</groupId> <artifactId>artifact</artifactId> <version>1.0.0</version> </dependency> </dependencies>',193,1),
('Dependencia letöltése: A Maven a dependenciákat az internetről a Maven Central Repository-ból tölti le.',194,1),
('Lokális repozitórium szerepe: A Maven a lokális repozitóriumot használja a letöltött dependenciák és létrehozott artifaktok tárolására a fejlesztő gépén.',195,1),
('Lokális repozitórium elérhetőség: Ha a lokális repozitóriumban már elérhető a hivatkozott dependencia, a Maven nem tölti le újra az internetről.',196,1),
('artifactId szerepe: Az artifactId az adott projekt által generált artifaktum (build) nevét határozza meg.',197,1),
('groupId szerepe: A groupId azonosítja az adott projekt csoportját vagy szervezetét. Gyakran a vállalati domain fordított alakját használják.',198,1),
('Kliens-szerver kommunikáció működése: A kliens küld kérést a szervernek, a szerver válaszol a kérésre. Az üzeneteket általában HTTP protokollon keresztül továbbítják.',199,1),
('Fontosabb HTTP portok: 1. HTTP (nem titkosított): 80. 2. HTTPS (titkosított): 443.',200,1),
('Fontosabb HTTP status kódok: 1. 200 OK: A kérés sikeres. 2. 404 Not Found: Az erőforrás nem található. 3. 500 Internal Server Error: Szerveroldali hiba.',201,1),
('WebProfile és Full Platform: 1. WebProfile: Ebben megtalálhatók az olyan technológiák, mint a Servlet, JSP, JSF. 2. Full Platform: Tartalmazza a WebProfile-t, valamint kiegészül más Java EE technológiákkal, például EJB, JMS.',202,1),
('SOAP (Simple Object Access Protocol): Egy protokoll, amelyet webes szolgáltatások kommunikációjára használnak XML formátumban. Általában HTTP vagy SMTP protokollon keresztül továbbítják.',203,1),
('Szervletek használata: A szervletek szerveroldalon futó Java alkalmazások, amelyek kliens kérésekre válaszolnak. A szervletek dinamikus tartalmat generálnak a böngésző számára.',204,1),
('Alapértelmezett szervlet metódusok: 1. doGet(): A GET kéréseket kezeli. 2. doPost(): A POST kéréseket kezeli. 3. doPut(): A PUT kéréseket kezeli. 4. doDelete(): A DELETE kéréseket kezeli.',205,1),
('JSP (JavaServer Pages) használata: A JSP technológia dinamikus webes tartalmat készít Java alapú sablonok segítségével. A Java kódot a HTML kóddal vegyítik.',206,1),
('include parancs szerepe: Az include parancs segítségével más JSP oldalakat lehet beilleszteni egy JSP oldalba. Ezáltal újrahasznosítható és könnyen karbantartható kód hozható létre.',207,1),
('JAR fájlok telepítése: A JAR fájlokat a CLASSPATH környezeti változó vagy a -classpath opció használatával lehet telepíteni.',208,1),
('Bean-ek használata: A bean-ek Java osztályok, amelyeket a Spring konténer kezel. A bean-ek az alkalmazás komponenseinek nevezhetők, és különböző célokra használhatók, például adatmodell reprezentáció, üzleti logika, adatelérés, stb.',209,1),
('JSTL (JavaServer Pages Standard Tag Library): A JSTL egy JSP-ben használható könyvtár, amely segítségével könnyen lehet vezérelni a JSP oldalak logikáját és megjelenését. Néhány direktíva: 1. <c:if>: Elágazások készítésére. 2. <c:forEach>: Ciklusok készítésére. 3. <c:set>: Változók beállítására.',210,1),
('Spring Boot MVC modell értelmezése: A Spring Boot MVC modellje az alkalmazásnak a felhasználói felülettel való kommunikációját szabályozza. A model, a view és a controller rétegek segítségével könnyen elkülöníthetők a különböző felelősségi területek.',211,1),
('Spring Boot alkalmazás létrehozása: 1. Spring Initializr: A Spring Initializr weboldalon vagy parancssorból létrehozható alkalmazás. 2. Spring Boot CLI (Command Line Interface): Parancssorból használható eszköz. 3. Integrált fejlesztői környezetek (IDE): Például Eclipse, IntelliJ, stb.',212,1),
('Fontosabb Spring Boot modulok és komponensek: 1. Spring Boot Starter: Az alkalmazás függőségeit kezelő modul. 2. Spring Boot Auto-configuration: Automatikus konfiguráció az alkalmazásnak. 3. Spring Boot Actuator: Alkalmazás állapotát és működését monitorozó komponens.',213,1),
('Az eljárás-orientált nyelvek mindig hatékonyabbak. Az OOP nyelvek csak szöveges programozásra alkalmasak.',1,0),
('Absztrakció azt jelenti, hogy minden részletet meg kell jeleníteni egy objektumban. Az absztrakció csak az OOP nyelvekben létezik.',2,0),
('Megkülönböztetés csak az osztályozás része, nem önálló fogalom. A megkülönböztetés csak a szöveges adatoknál alkalmazható.',3,0),
('Az osztályozás csak az eljárás-orientált programozásban használatos. Az osztályozás csak a matematikában fontos.',4,0),
('Az általánosítás és specializálás ugyanazt jelenti. Az általánosítás csak az OOP nyelvekben lehetséges.',5,0),
('Az OOP csak az adatok rendezésére szolgál. Az OOP csak az eljárás-orientált programok bonyolultságát növeli.',6,0),
('Az osztály csak adattagok gyűjteménye. Az osztályok csak akkor hasznosak, ha nincsenek bonyolult kapcsolatok az objektumok között.',7,0),
('Az objektumpéldány csak egy szimpla változó. Az objektumpéldányok csak az adatok tárolására használhatók.',8,0),
('Az Object osztály csak az alapvető adattípusokhoz kapcsolódik. Az Object osztály csak az eljárás-orientált programokban szükséges.',9,0),
('A Wrapper osztályok csak a karaktereket kezelik. A Wrapper osztályok csak az öröklődéshez használhatók.',10,0),
('A "super" kulcsszó csak az interface-ekben használható. A "super" kulcsszó csak az öröklődésnél alkalmazható.',11,0),
('Az "extends" kulcsszó csak az interface-eknél használható. Az "extends" kulcsszó csak az öröklődésnél alkalmazható.',12,0),
('Az "implements" kulcsszó csak az öröklődésnél használható. Az "implements" kulcsszó csak a változók deklarálásánál alkalmazható.',13,0),
('A POJO csak az öröklődésnél alkalmazható. A POJO csak a változók deklarálásánál hasznos.',14,0),
('Az egységbezárás csak az objektumok létrehozásánál alkalmazható. Az egységbezárás csak a változók deklarálásánál hasznos.',15,0),
('Az információrejtés csak az objektumok létrehozásánál alkalmazható. Az információrejtés csak a változók deklarálásánál hasznos.',16,0),
('Az öröklődés csak a változók deklarálásánál alkalmazható. Az öröklődés csak az eljárás-orientált programokban hasznos.',17,0),
('A polimorfizmus csak az objektumok létrehozásánál alkalmazható. A polimorfizmus csak a változók deklarálásánál hasznos.',18,0),
('A konstruktor csak az objektumok létrehozásánál alkalmazható. A konstruktor csak a változók deklarálásánál hasznos.',19,0),
('A konstruktor csak az objektumok létrehozásánál alkalmazható. A konstruktor csak a változók deklarálásánál hasznos.',20,0),
('A konstruktor túlterhelése csak az objektumok létrehozásánál alkalmazható. A konstruktor túlterhelése csak a változók deklarálásánál hasznos.',21,0),
('A destruktor szükséges az objektumok felszabadításához. A destruktor csak az objektumok létrehozásánál alkalmazható.',22,0),
('A Garbage Collector csak az objektumok létrehozásánál alkalmazható. A Garbage Collector csak a változók deklarálásánál hasznos.',23,0),
('A láthatósági szintek csak az objektumok létrehozásánál alkalmazhatók. A láthatósági szintek csak a változók deklarálásánál hasznosak.',24,0),
('A nem látható mező eléréséhez elegendő a public láthatóság. A nem látható mező elérhető más osztályokban is.',25,0),
('A "static" kulcsszó csak a példányok létrehozásánál alkalmazható. A "static" kulcsszó csak a változók deklarálásánál hasznos.',26,0),
('A "final" kulcsszó csak a példányok létrehozásánál alkalmazható. A "final" kulcsszó csak a változók deklarálásánál hasznos.',27,0),
('A "this" kulcsszó csak a példányok létrehozásánál alkalmazható. A "this" kulcsszó csak a változók deklarálásánál hasznos.',28,0),
('A mező csak az osztályon kívül definiálható. A mező csak a változók deklarálásánál hasznos.',29,0),
('A property csak az osztályon kívül definiálható. A property csak a változók deklarálásánál hasznos.',30,0),
('Gettereket csak az osztályon kívül használjuk. Setterek csak az osztályon kívül használhatók.',31,0),
('Konvenció szerint a gettereket és settereket mindig az osztály elejére helyezzük. A konstruktorokat mindig a végére.',32,0),
('Többszörös öröklődés esetén az osztályok az összes örökölt tulajdonságot öröklik. Többszörös öröklődés csak az objektumok létrehozásánál alkalmazható.',33,0),
('A Java SE csak a szöveges programozásban hasznos. A Java SE csak az objektumok létrehozásánál alkalmazható.',34,0),
('A Java EE csak az objektumok létrehozásánál alkalmazható. A Java EE csak a változók deklarálásánál hasznos.',35,0),
('A JDK csak az objektumok létrehozásánál alkalmazható. A JDK csak a változók deklarálásánál hasznos.',36,0),
('A JRE csak az objektumok létrehozásánál alkalmazható. A JRE csak a változók deklarálásánál hasznos.',37,0),
('A JVM csak az objektumok létrehozásánál alkalmazható. A JVM csak a változók deklarálásánál hasznos.',38,0),
('A "javac" csak a szöveges programozásban hasznos. A "javac" csak az objektumok létrehozásánál alkalmazható.',39,0),
('A JIT csak az objektumok létrehozásánál alkalmazható. A JIT csak a változók deklarálásánál hasznos.',40,0),
('A Java kódok fordítása csak az objektumok létrehozásánál alkalmazható. A Java kódok fordítása csak a változók deklarálásánál hasznos.',41,0),
('A "java.io" csomag használata csak a szöveges programozásban hasznos. A "java.io" csomag használata csak az objektumok létrehozásánál alkalmazható.',42,0),
('A "java.sql" csomag használata csak a szöveges programozásban hasznos. A "java.sql" csomag használata csak az objektumok létrehozásánál alkalmazható.',43,0),
('A "java.awt" csomag használata csak a szöveges programozásban hasznos. A "java.awt" csomag használata csak az objektumok létrehozásánál alkalmazható.',44,0),
('A "java.math" csomag használata csak a szöveges programozásban hasznos. A "java.math" csomag használata csak az objektumok létrehozásánál alkalmazható.',45,0),
('A "java.beans" csomag használata csak a szöveges programozásban hasznos. A "java.beans" csomag használata csak az objektumok létrehozásánál alkalmazható.',46,0),
('A "java.util" csomag használata csak a szöveges programozásban hasznos. A "java.util" csomag használata csak az objektumok létrehozásánál alkalmazható.',47,0),
('A "Math" osztály csak a szöveges programozásban hasznos. A "Math" osztály csak az objektumok létrehozásánál alkalmazható.',48,0),
('A primitív típusok csak az objektumok létrehozásánál alkalmazhatók. A primitív típusok csak a változók deklarálásánál hasznosak.',49,0),
('Az összetett típusok csak a szöveges programozásban hasznosak. Az összetett típusok csak az objektumok létrehozásánál alkalmazhatók.',50,0),
('A matematikai operátorok csak az objektumok létrehozásánál alkalmazhatók. A matematikai operátorok csak a változók deklarálásánál hasznosak.',51,0),
('A relációs operátorok csak a szöveges programozásban hasznosak. A relációs operátorok csak az objektumok létrehozásánál alkalmazhatók.',52,0),
('A logikai operátorok csak a matematikai műveletekhez használhatók.',53,0),
('Prefix és postfix értéknövelés csak a szöveges programozásban hasznos. Prefix és postfix értéknövelés csak az objektumok létrehozásánál alkalmazható.',54,0),
('A "Scanner" csak a szöveges programozásban hasznos. A "Scanner" csak az objektumok létrehozásánál alkalmazhatók.',55,0),
('Az adatok átalakítása String típusba csak a szöveges programozásban hasznos. Az adatok átalakítása String típusba csak az objektumok létrehozásánál alkalmazhatók.',56,0),
('A Java erősen típusos nyelv csak a szöveges programozásban hasznos. A Java erősen típusos nyelv csak az objektumok létrehozásánál alkalmazhatók.',57,0),
('A változó létrehozásának szempontjai csak a szöveges programozásban hasznosak. A változó létrehozásának szempontjai csak az objektumok létrehozásánál alkalmazhatók.',58,0),
('A switch-case szerkezet csak a szöveges programozásban hasznos. A switch-case szerkezet csak az objektumok létrehozásánál alkalmazhatók.',59,0),
('A "default" ág csak a szöveges programozásban hasznos. A "default" ág csak az objektumok létrehozásánál alkalmazhatók.',60,0),
('A "break" csak a szöveges programozásban hasznos. A "break" csak az objektumok létrehozásánál alkalmazhatók.',61,0),
('A "break" és "continue" csak a szöveges programozásban hasznos. A "break" és "continue" csak az objektumok létrehozásánál alkalmazhatók.',62,0),
('A ciklusok Java-ban csak a szöveges programozásban hasznosak.',63,0),
('Az elágazások Java-ban csak a szöveges programozásban hasznosak.',64,0),
('A "while" és "do-while" ciklusok közötti különbség csak a szöveges programozásban hasznos.',65,0),
('A programozási tételek csak a szöveges programozásban hasznosak.',66,0),
('A "void" kulcsszó használata csak a szöveges programozásban hasznos.',67,0),
('A formális paraméterek csak a szöveges programozásban hasznosak. A formális paraméterek csak az objektumok létrehozásánál alkalmazhatók.',68,0),
('A metódus túlterhelése csak a szöveges programozásban hasznos. A metódus túlterhelése csak az objektumok létrehozásánál alkalmazhatók.',69,0),
('A metódus szignatúrája csak a szöveges programozásban hasznos. A metódus szignatúrája csak az objektumok létrehozásánál alkalmazhatók.',70,0),
('A metódus deklaráció és hívás közötti különbség csak a szöveges programozásban hasznos.',71,0),
('A tömbök használata csak a szöveges programozásban hasznos. A tömbök használata csak az objektumok létrehozásánál alkalmazhatók.',72,0),
('A tömb elemeinek hivatkozása csak a szöveges programozásban hasznos.',73,0),
('A tömbkezelő metódusok csak a szöveges programozásban hasznosak. A tömbkezelő metódusok csak az objektumok létrehozásánál alkalmazhatók.',74,0),
('Rendező algoritmusok csak a szöveges programozásban vannak. Rendező algoritmusok csak az objektumok létrehozásánál alkalmazhatók.',75,0),
('A rendező algoritmusok jóságát meghatározza csak a szöveges programozásban. A rendező algoritmusok jóságát meghatározza csak az objektumok létrehozásánál.',76,0),
('Fájl létrehozása csak a szöveges programozásban hasznos. Fájl létrehozása csak az objektumok létrehozásánál alkalmazhatók.',77,0),
('A fájl lezárása csak a szöveges programozásban fontos. A fájl lezárása csak az objektumok létrehozásánál alkalmazhatók.',78,0),
('Fájlból olvasás csak a szöveges programozásban lehetséges. Fájlból olvasás csak az objektumok létrehozásánál alkalmazhatók.',79,0),
('Pointerek vannak a Java-ban, de más nevet kapnak. A pointerek csak a szöveges programozásban vannak.',80,0),
('A split függvényt csak a szöveges programozásban lehet használni. A split függvényt csak az objektumok létrehozásánál alkalmazhatók.',81,0),
('A "split" metódust csak a szöveges programozásban hasznos. A "split" metódust csak az objektumok létrehozásánál alkalmazhatók.',82,0),
('A "concat" metódust csak a szöveges programozásban hasznos. A "concat" metódust csak az objektumok létrehozásánál alkalmazhatók.',83,0),
('A "format" metódust csak a szöveges programozásban hasznos. A "format" metódust csak az objektumok létrehozásánál alkalmazhatók.',84,0),
('A "substring" metódust csak a szöveges programozásban hasznos. A "substring" metódust csak az objektumok létrehozásánál alkalmazhatók.',85,0),
('A "contains" metódust csak a szöveges programozásban hasznos. A "contains" metódust csak az objektumok létrehozásánál alkalmazhatók.',86,0),
('Az "equals" metódust csak a szöveges programozásban hasznos. Az "equals" metódust csak az objektumok létrehozásánál alkalmazhatók.',87,0),
('A "replace" metódust csak a szöveges programozásban hasznos. A "replace" metódust csak az objektumok létrehozásánál alkalmazhatók.',88,0),
('Az "indexOf" metódust csak a szöveges programozásban hasznos. Az "indexOf" metódust csak az objektumok létrehozásánál alkalmazhatók.',89,0),
('A java.util package-ben található Date, Calendar osztályokat érdemes használni dátumkezelésre.',90,0),
('A LocalDate, LocalTime, LocalDateTime osztályok is elavultak.',91,0),
('A dátumok összehasonlítása csak a szöveges programozásban hasznos.',92,0),
('Rekurzióval csak az összeadás és kivonás feladatok oldhatók meg.',93,0),
('A rekurzív algoritmusok csak a szöveges programozásban hasznosak.',94,0),
('A Java LTS verziói csak a szöveges programozásban vannak.',95,0),
('A Java 8 újdonságai csak a szöveges programozásban vannak.',96,0),
('A Java 11 újdonságai csak a szöveges programozásban vannak.',97,0),
('A Java 17 újdonságai csak a szöveges programozásban vannak.',98,0),
('A JCF csak a szöveges programozásban hasznos.',99,0),
('A JCF csak egy interfészt és egy osztályt tartalmaz.',100,0),
('A List interfész csak a szöveges programozásban hasznos.',101,0),
('A Set interfész csak a szöveges programozásban hasznos.',102,0),
('A Map interfész csak a szöveges programozásban hasznos.',103,0),
('A List interfész implementációi csak a szöveges programozásban vannak.',104,0),
('A Set interfész implementációi csak a szöveges programozásban vannak.',105,0),
('A Map interfész implementációi csak a szöveges programozásban vannak.',106,0),
('Az ArrayList osztály csak a szöveges programozásban hasznos.',107,0),
('A LinkedList osztály csak a szöveges programozásban hasznos.',108,0),
('A Stack osztály csak a szöveges programozásban hasznos.',109,0),
('A Hashtable osztály csak a szöveges programozásban hasznos.',110,0),
('Az ArrayList osztály delete(int index) metódusával lehet index alapján eltávolítani egy elemet.',111,0),
('Az Collections osztály arrange metódusával lehet csökkenő sorrendbe rendezni egy listát.',112,0),
('Az Collections osztály arrange metódusával lehet növekvő sorrendbe rendezni egy listát.',113,0),
('Az ArrayList és a sima tömb használata között nincs különbség.',114,0),
('A ArrayList osztálynak nincsenek használható metódusai.',115,0),
('Az interface-ek és az absztrakt osztályok használata között nincs különbség.',116,0),
('A Hashtable osztálynál a for ciklus teljesen működik.',117,0),
('Az interface-ek csak a szöveges programozásban hasznosak.',118,0),
('Az alkalmazás rétegezett felépítése csak a szöveges programozásban hasznos.',119,0),
('Az MVC tervezési minta csak a szöveges programozásban hasznos.',120,0),
('A Model réteg csak a szöveges programozásban hasznos.',121,0),
('A View réteg csak a szöveges programozásban hasznos.',122,0),
('A Controller réteg csak a szöveges programozásban hasznos.',123,0),
('Az MVP tervezési minta csak a szöveges programozásban hasznos.',124,0),
('Az MVVM tervezési minta csak a szöveges programozásban hasznos.',125,0),
('A DTO-k csak a szöveges programozásban hasznosak.',126,0),
('A DAO réteg csak a szöveges programozásban hasznos.',127,0),
('A service réteg csak a szöveges programozásban hasznos.',128,0),
('A repository réteg csak a szöveges programozásban hasznos.',129,0),
('A reguláris kifejezéseket csak a szöveges programozásban hasznos.',130,0),
('A reguláris kifejezésekben csak sima karakterek használhatók.',131,0),
('A kivételek csak a szöveges programozásban hasznosak.',132,0),
('Az összes kivételkezelő osztály ugyanazt a hibát jelzi.',133,0),
('Saját kivételkezelő osztály csak a szöveges programozásban hozható létre.',134,0),
('Checked kivételek csak a szöveges programozásban fordulnak elő.',135,0),
('A try-catch szerkezet nem használható a szöveges programozásban.',136,0),
('A finally kulcsszó csak a szöveges programozásban hasznos.',137,0),
('A predicate-ek csak a szöveges programozásban hasznosak.',138,0),
('A functional interface-ek csak a szöveges programozásban hasznosak.',139,0),
('A lambda kifejezések csak a szöveges programozásban hasznosak.',140,0),
('A lambda kifejezések szintaxisa csak a szöveges programozásban alkalmazható.',141,0),
('A StreamAPI csak a szöveges programozásban hasznos.',142,0),
('A Stream API szintaxisa csak a szöveges programozásban alkalmazható.',143,0),
('A szálak létrehozásához az Object osztályt használjuk.',144,0),
('A többszálú alkalmazások készítése csak a szöveges programozásban lehetséges.',145,0),
('A synchronized kulcsszót csak a szöveges programozásban lehet használni.',146,0),
('A start metódus csak a szöveges programozásban hasznos.',147,0),
('A join metódus csak a szöveges programozásban hasznos.',148,0),
('A sleep metódus csak a szöveges programozásban hasznos.',149,0),
('A többszálú alkalmazások készítése csak a szöveges programozásban lehetséges.',150,0),
('Az URL osztály csak a szöveges programozásban hasznos.',151,0),
('Az XML és JSON ugyanaz, csak más néven.',152,0),
('A Gson osztály csak a szöveges programozásban hasznos.',153,0),
('Az XML feldolgozásához csak az objektumok létrehozásával dolgozhatunk.',154,0),
('A JSON feldolgozásához csak az objektumok létrehozásával dolgozhatunk.',155,0),
('A Timer és TimerTask osztályokat csak az objektumok létrehozásával dolgozhatunk.',156,0),
('A Reflection API csak az objektumok létrehozásával dolgozhatunk.',157,0),
('A legfontosabb osztályok a java.util csomagban találhatóak.',158,0),
('A Connection osztály csak a szöveges programozásban hasznos.',159,0),
('A Statement osztály csak a szöveges programozásban hasznos.',160,0),
('A DriverManager osztály csak a szöveges programozásban hasznos.',161,0),
('Az SQLException osztály csak a szöveges programozásban hasznos.',162,0),
('A Prepared Statement használata nem befolyásolja a teljesítményt.',163,0),
('A ResultSet csak az objektumok létrehozására szolgál.',164,0),
('A ResultSet indexei nem léteznek.',165,0),
('A JPA csak a szöveges programozásban hasznos.',166,0),
('A Hibernate csak a szöveges programozásban hasznos.',167,0),
('Az esemény-vezérelt alkalmazások csak a szöveges programozásban lehetségesek.',168,0),
('Esemény csak felhasználói interakció lehet.',169,0),
('Az események csak két csoportba sorolhatók.',170,0),
('AWT-t mindig érdemes használni.',171,0),
('A look-and-feel támogatás csak a szöveges programozásban hasznos.',172,0),
('A Swing-es grafikus felület csak a szöveges programozásban lehetséges.',173,0),
('A felugró ablakot csak a JavaFX támogatja.',174,0),
('A pipálható mezőt csak a JavaFX támogatja.',175,0),
('A rádió gombot csak a JavaFX támogatja.',176,0),
('A legördülő menüt csak a JavaFX támogatja.',177,0),
('A címkét csak a JavaFX támogatja.',178,0),
('A szöveges beviteli mezőt csak a JavaFX támogatja.',179,0),
('A jelszó típusú beviteli mezőt csak a JavaFX támogatja.',180,0),
('A gombot csak a JavaFX támogatja.',181,0),
('A tárolót csak a JavaFX támogatja.',182,0),
('A komponensek csoportosítását csak a JavaFX támogatja.',183,0),
('A JavaFX-es grafikus felület csak szöveges programozásban készíthető.',184,0),
('A Swing csak egyféle layout-ot támogat.',185,0),
('A JavaFX csak egyféle layout-ot támogat.',186,0),
('A láthatóságot csak a JavaFX támogatja.',187,0),
('Az elérhetőséget csak a JavaFX támogatja.',188,0),
('A Maven csak egyféle projekttípust támogat.',189,0),
('A pom.xml csak egy példa fájl, nem befolyásolja a projekt működését.',190,0),
('Az életciklus csak az első három lépésből áll.',191,0),
('A compile csak a forráskódot ellenőrzi.',192,0),
('A függőség csak a projekt forráskódját érinti.',193,0),
('A dependenciákat csak a fejlesztő saját gépéről lehet letölteni.',194,0),
('A lokális repozitórium csak a Maven beállításaihoz használható.',195,0),
('A Maven mindig újra letölti a dependenciákat, függetlenül a lokális elérhetőségtől.',196,0),
('Az artifactId csak a forráskód nevét határozza meg.',197,0),
('A groupId csak a projekt nevét határozza meg.',198,0),
('A kliens-szerver kommunikáció során mindig a kliens küldi az üzeneteket.',199,0),
('Az HTTP és HTTPS ugyanazt a portot használja.',200,0),
('A 200 OK mindig azt jelenti, hogy az erőforrás megtalálható.',201,0),
('A WebProfile csak az EJB technológiát tartalmazza.',202,0),
('SOAP csak szöveges adatokat támogat.',203,0),
('A szervletek csak statikus tartalmat szolgáltatnak.',204,0),
('A szervleteknek nincsenek alapértelmezett metódusaik.',205,0),
('A JSP csak statikus HTML oldalak készítésére használható.',206,0),
('Az include parancs csak CSS fájlok beillesztésére használható.',207,0),
('A JAR fájlokat csak a JAVA_HOME környezeti változó segítségével lehet telepíteni.',208,0),
('A bean-ek csak adatelérésre használhatók.',209,0),
('A JSTL csak a felhasználói felület megjelenítésére használható.',210,0),
('A Spring Boot MVC modell csak adatelérésre szolgál.',211,0),
('A Spring Boot alkalmazás csak parancssorból hozható létre.',212,0),
('A Spring Boot Starter csak a felhasználói felülettel foglalkozik.',213,0),
('Az OOP nyelvek nem használnak eljárásokat. Az eljárás-orientált nyelvek objektumorientáltak.',1,0),
('Az absztrakció csak a számokkal való műveleteknél alkalmazható. Az absztrakció nem segít az adatok rendezésében.',2,0),
('A megkülönböztetés nem szükséges az informatikában. A megkülönböztetés azonos objektumok közötti különbségek kiemelését szolgálja.',3,0),
('Az osztályozás csak a szöveges programozásban alkalmazható. Az osztályozás az objektumok méretét határozza meg.',4,0),
('Az általánosítás csak az eljárás-orientált nyelvekben alkalmazható. Az általánosítás nem szükséges az objektumorientált programozásban.',5,0),
('Az OOP csak statikus programokhoz alkalmazható. Az OOP csak a kisebb projektek számára előnyös.',6,0),
('Az osztályok csak a kódsorok csoportosítását szolgálják. Az osztályoknak nincs szerepük az objektumok létrehozásában.',7,0),
('Az objektumpéldányoknak nincs szerepük a program futása során. Az objektumpéldányok csak a kódsorok csoportosítását szolgálják.',8,0),
('Az Object osztály csak a számokkal való műveleteknél alkalmazható. Az Object osztály csak az adatok rendezésére szolgál.',9,0),
('A Wrapper osztályok csak a matematikai műveletekhez használhatók. A Wrapper osztályok csak a fejlesztőknek fontosak.',10,0),
('A "super" kulcsszó csak az objektumok létrehozásánál hasznos. A "super" kulcsszó csak az eljárás-orientált programokban szükséges.',11,0),
('Az "extends" kulcsszó csak a változók deklarálásánál hasznos. Az "extends" kulcsszó csak az eljárás-orientált programokban szükséges.',12,0),
('Az "implements" kulcsszó csak az eljárás-orientált programokban hasznos. Az "implements" kulcsszó csak a szöveges programozásban fontos.',13,0),
('A POJO csak az eljárás-orientált programokban hasznos. A POJO csak a matematikai műveletekhez használható.',14,0),
('Az egységbezárás csak az eljárás-orientált programokban hasznos. Az egységbezárás csak a szöveges programozásban fontos.',15,0),
('Az információrejtés csak az eljárás-orientált programokban hasznos. Az információrejtés csak a szöveges programozásban fontos.',16,0),
('Az öröklődés csak a szöveges programozásban fontos. Az öröklődés csak az objektumok létrehozásánál hasznos.',17,0),
('A polimorfizmus csak az eljárás-orientált programokban hasznos. A polimorfizmus csak a szöveges programozásban fontos.',18,0),
('A konstruktor csak az eljárás-orientált programokban hasznos. A konstruktor csak a szöveges programozásban fontos.',19,0),
('A konstruktor csak az eljárás-orientált programokban hasznos. A konstruktor csak a szöveges programozásban fontos.',20,0),
('A konstruktor túlterhelése csak az eljárás-orientált programokban hasznos. A konstruktor túlterhelése csak a szöveges programozásban fontos.',21,0),
('A destruktor csak a változók deklarálásánál hasznos. A destruktor csak az eljárás-orientált programokban fontos.',22,0),
('A Garbage Collector csak az eljárás-orientált programokban hasznos. A Garbage Collector csak a szöveges programozásban fontos.',23,0),
('A láthatósági szintek csak az eljárás-orientált programokban hasznosak. A láthatósági szintek csak a szöveges programozásban fontosak.',24,0),
('A nem látható mező eléréséhez elegendő a protected láthatóság. A nem látható mező elérhető más csomagokban is.',25,0),
('A "static" kulcsszó csak az eljárás-orientált programokban hasznos. A "static" kulcsszó csak a szöveges programozásban fontos.',26,0),
('A "final" kulcsszó csak az eljárás-orientált programokban hasznos. A "final" kulcsszó csak a szöveges programozásban fontos.',27,0),
('A "this" kulcsszó csak az eljárás-orientált programokban hasznos. A "this" kulcsszó csak a szöveges programozásban fontos.',28,0),
('A mező csak az eljárás-orientált programokban hasznos. A mező csak a szöveges programozásban fontos.',29,0),
('A property csak az eljárás-orientált programokban hasznos. A property csak a szöveges programozásban fontos.',30,0),
('Getterek csak az eljárás-orientált programokban hasznosak. Setterek csak a szöveges programozásban fontosak.',31,0),
('Konvenció szerint a mezőket csak az osztály végén szabad elhelyezni. A mezőket csak a getterek és setterek után lehet definiálni.',32,0),
('Többszörös öröklődés esetén az osztályoknak minden tulajdonságát be kell fejezniük. Többszörös öröklődés csak a változók deklarálásánál hasznos.',33,0),
('A Java SE csak az eljárás-orientált programokban hasznos. A Java SE csak a matematikai műveletekhez használható.',34,0),
('A Java EE csak az eljárás-orientált programokban hasznos. A Java EE csak a matematikai műveletekhez használható.',35,0),
('A JDK csak az eljárás-orientált programokban hasznos. A JDK csak a matematikai műveletekhez használható.',36,0),
('A JRE csak az eljárás-orientált programokban hasznos. A JRE csak a matematikai műveletekhez használható.',37,0),
('A JVM csak az eljárás-orientált programokban hasznos. A JVM csak a matematikai műveletekhez használható.',38,0),
('A "javac" csak az eljárás-orientált programokban hasznos. A "javac" csak a matematikai műveletekhez használható.',39,0),
('A JIT csak az eljárás-orientált programokban hasznos. A JIT csak a matematikai műveletekhez használható.',40,0),
('A Java kódok fordítása csak az eljárás-orientált programokban hasznos. A Java kódok fordítása csak a matematikai műveletekhez használható.',41,0),
('A "java.io" csomag használata csak az eljárás-orientált programokban hasznos. A "java.io" csomag használata csak a matematikai műveletekhez használható.',42,0),
('A "java.sql" csomag használata csak az eljárás-orientált programokban hasznos. A "java.sql" csomag használata csak a matematikai műveletekhez használható.',43,0),
('A "java.awt" csomag használata csak az eljárás-orientált programokban hasznos. A "java.awt" csomag használata csak a matematikai műveletekhez használható.',44,0),
('A "java.math" csomag használata csak az eljárás-orientált programokban hasznos. A "java.math" csomag használata csak a grafikus felület kialakításánál fontos.',45,0),
('A "java.beans" csomag használata csak az eljárás-orientált programokban hasznos. A "java.beans" csomag használata csak a matematikai műveletekhez használható.',46,0),
('A "java.util" csomag használata csak az eljárás-orientált programokban hasznos. A "java.util" csomag használata csak a matematikai műveletekhez használható.',47,0),
('A "Math" osztály csak az eljárás-orientált programokban hasznos. A "Math" osztály csak a grafikus felület kialakításánál fontos.',48,0),
('A primitív típusok csak az eljárás-orientált programokban hasznosak. A primitív típusok csak a matematikai műveletekhez használhatók.',49,0),
('Az összetett típusok csak az eljárás-orientált programokban hasznosak. Az összetett típusok csak a matematikai műveletekhez használhatók.',50,0),
('A matematikai operátorok csak az eljárás-orientált programokban hasznosak. A matematikai operátorok csak a relációs operátorokkal kombinálva alkalmazhatók.',51,0),
('A relációs operátorok csak az eljárás-orientált programokban hasznosak. A relációs operátorok csak a matematikai műveletekhez használhatók.',52,0),
('A logikai operátorok csak a szöveges programozásban hasznosak.',53,0),
('Prefix és postfix értéknövelés csak az eljárás-orientált programokban hasznos. Prefix és postfix értéknövelés csak a matematikai műveletekhez használható.',54,0),
('A "BufferedReader" csak az eljárás-orientált programokban hasznos. A "BufferedReader" csak a matematikai műveletekhez használhatók.',55,0),
('Az adatok átalakítása String típusba csak az eljárás-orientált programokban hasznos. Az adatok átalakítása String típusba csak a matematikai műveletekhez használhatók.',56,0),
('A Java erősen típusos nyelv csak az eljárás-orientált programokban hasznos. A Java erősen típusos nyelv csak a matematikai műveletekhez használhatók.',57,0),
('A változó létrehozásának szempontjai csak az eljárás-orientált programokban hasznosak. A változó létrehozásának szempontjai csak a matematikai műveletekhez használhatók.',58,0),
('A switch-case szerkezet csak az eljárás-orientált programokban hasznos. A switch-case szerkezet csak a matematikai műveletekhez használhatók.',59,0),
('A "default" ág csak az eljárás-orientált programokban hasznos. A "default" ág csak a matematikai műveletekhez használhatók.',60,0),
('A "break" csak az eljárás-orientált programokban hasznos. A "break" csak a matematikai műveletekhez használhatók.',61,0),
('A "break" és "continue" csak az eljárás-orientált programokban hasznos. A "break" és "continue" csak a matematikai műveletekhez használhatók.',62,0),
('A ciklusok Java-ban csak az objektumok létrehozásánál alkalmazhatók.',63,0),
('Az elágazások Java-ban csak az objektumok létrehozásánál alkalmazhatók.',64,0),
('A "while" és "do-while" ciklusok közötti különbség csak az objektumok létrehozásánál alkalmazhatók.',65,0),
('A programozási tételek csak az objektumok létrehozásánál alkalmazhatók.',66,0),
('A "void" kulcsszó használata csak az objektumok létrehozásánál alkalmazhatók.',67,0),
('Az aktuális paraméterek csak az eljárás-orientált programokban hasznosak. Az aktuális paraméterek csak a matematikai műveletekhez használhatók.',68,0),
('A metódus túlterhelése csak az eljárás-orientált programokban hasznos. A metódus túlterhelése csak a matematikai műveletekhez használhatók.',69,0),
('A metódus szignatúrája csak az eljárás-orientált programokban hasznos. A metódus szignatúrája csak a matematikai műveletekhez használhatók.',70,0),
('A metódus deklaráció és hívás közötti különbség csak az objektumok létrehozásánál alkalmazhatók.',71,0),
('A tömbök használata csak az eljárás-orientált programokban hasznos. A tömbök használata csak a matematikai műveletekhez használhatók.',72,0),
('A tömb elemeinek hivatkozása csak az objektumok létrehozásánál alkalmazhatók.',73,0),
('A tömbkezelő metódusok csak az eljárás-orientált programokban hasznosak. A tömbkezelő metódusok csak a matematikai műveletekhez használhatók.',74,0),
('Rendező algoritmusok csak az eljárás-orientált programokban vannak. Rendező algoritmusok csak a matematikai műveletekhez használhatók.',75,0),
('A rendező algoritmusok jóságát meghatározza csak az eljárás-orientált programokban. A rendező algoritmusok jóságát meghatározza csak a matematikai műveletekhez.',76,0),
('Fájl létrehozása csak az eljárás-orientált programokban hasznos. Fájl létrehozása csak a matematikai műveletekhez használhatók.',77,0),
('A fájl lezárása csak az eljárás-orientált programokban fontos. A fájl lezárása csak a matematikai műveletekhez használhatók.',78,0),
('Fájlból olvasás csak az eljárás-orientált programokban lehetséges. Fájlból olvasás csak a matematikai műveletekhez használhatók.',79,0),
('A pointerek csak az eljárás-orientált programokban vannak. A pointerek csak a matematikai műveletekhez használhatók.',80,0),
('A split függvényt csak az eljárás-orientált programokban lehet használni. A split függvényt csak a matematikai műveletekhez használhatók.',81,0),
('A "split" metódust csak az eljárás-orientált programokban hasznos. A "split" metódust csak a matematikai műveletekhez használhatók.',82,0),
('A "concat" metódust csak az eljárás-orientált programokban hasznos. A "concat" metódust csak a matematikai műveletekhez használhatók.',83,0),
('A "format" metódust csak az eljárás-orientált programokban hasznos. A "format" metódust csak a matematikai műveletekhez használhatók.',84,0),
('A "substring" metódust csak az eljárás-orientált programokban hasznos. A "substring" metódust csak a matematikai műveletekhez használhatók.',85,0),
('A "contains" metódust csak az eljárás-orientált programokban hasznos. A "contains" metódust csak a matematikai műveletekhez használhatók.',86,0),
('Az "equals" metódust csak az eljárás-orientált programokban hasznos. Az "equals" metódust csak a matematikai műveletekhez használhatók.',87,0),
('A "replace" metódust csak az eljárás-orientált programokban hasznos. A "replace" metódust csak a matematikai műveletekhez használhatók.',88,0),
('Az "indexOf" metódust csak az eljárás-orientált programokban hasznos. Az "indexOf" metódust csak a matematikai műveletekhez használhatók.',89,0),
('A java.sql package-ben található dátumkezelő osztályokat érdemes használni.',90,0),
('A ZonedDateTime osztály is elavult.',91,0),
('A dátumok összehasonlítása csak az objektumok létrehozásánál alkalmazható.',92,0),
('Rekurzióval csak a matematikai műveletekkel kapcsolatos feladatok oldhatók meg.',93,0),
('A rekurzív algoritmusok csak az objektumok létrehozásánál alkalmazhatók.',94,0),
('A Java LTS verziói csak az objektumok létrehozásánál alkalmazhatók.',95,0),
('A Java 8 újdonságai csak az objektumok létrehozásánál alkalmazhatók.',96,0),
('A Java 11 újdonságai csak az objektumok létrehozásánál alkalmazhatók.',97,0),
('A Java 17 újdonságai csak az objektumok létrehozásánál alkalmazhatók.',98,0),
('A JCF csak az objektumok létrehozásánál alkalmazhatók.',99,0),
('A JCF csak a szöveges programozásban hasznos.',100,0),
('A List interfész csak az objektumok létrehozásánál alkalmazhatók.',101,0),
('A Set interfész csak az objektumok létrehozásánál alkalmazhatók.',102,0),
('A Map interfész csak az objektumok létrehozásánál alkalmazhatók.',103,0),
('A List interfész implementációi csak az objektumok létrehozásánál alkalmazhatók.',104,0),
('A Set interfész implementációi csak az objektumok létrehozásánál alkalmazhatók.',105,0),
('A Map interfész implementációi csak az objektumok létrehozásánál alkalmazhatók.',106,0),
('Az ArrayList osztály csak az objektumok létrehozásánál alkalmazhatók.',107,0),
('A LinkedList osztály csak az objektumok létrehozásánál alkalmazhatók.',108,0),
('A Stack osztály csak az objektumok létrehozásánál alkalmazhatók.',109,0),
('A Hashtable osztály csak az objektumok létrehozásánál alkalmazhatók.',110,0),
('Az ArrayList osztály erase(int index) metódusával lehet index alapján eltávolítani egy elemet.',111,0),
('Az Collections osztály organize metódusával lehet csökkenő sorrendbe rendezni egy listát.',112,0),
('Az Collections osztály organize metódusával lehet növekvő sorrendbe rendezni egy listát.',113,0),
('Az ArrayList csak a szöveges programozásban hasznos, a sima tömb pedig az objektumok létrehozásánál alkalmazható.',114,0),
('Az ArrayList osztály csak a szöveges programozásban hasznos.',115,0),
('Az interface-ek csak a szöveges programozásban hasznosak.',116,0),
('A Hashtable osztálynál csak a szöveges programozásban működik a for ciklus.',117,0),
('Az interface-ek csak az objektumok létrehozásánál alkalmazhatók.',118,0),
('Az alkalmazás rétegezett felépítése csak az objektumok létrehozásánál alkalmazható.',119,0),
('Az MVC tervezési minta csak az objektumok létrehozásánál alkalmazható.',120,0),
('A Model réteg csak az objektumok létrehozásánál alkalmazható.',121,0),
('A View réteg csak az objektumok létrehozásánál alkalmazható.',122,0),
('A Controller réteg csak az objektumok létrehozásánál alkalmazható.',123,0),
('Az MVP tervezési minta csak az objektumok létrehozásánál alkalmazható.',124,0),
('Az MVVM tervezési minta csak az objektumok létrehozásánál alkalmazható.',125,0),
('A DTO-k csak az objektumok létrehozásánál alkalmazhatók.',126,0),
('A DAO réteg csak az objektumok létrehozásánál alkalmazható.',127,0),
('A service réteg csak az objektumok létrehozásánál alkalmazható.',128,0),
('A repository réteg csak az objektumok létrehozásánál alkalmazható.',129,0),
('A reguláris kifejezéseket csak az objektumok létrehozásánál alkalmazható.',130,0),
('A reguláris kifejezések csak egyetlen karakter keresésére alkalmasak.',131,0),
('A kivételek csak az objektumok létrehozásánál alkalmazhatók.',132,0),
('Csak egyetlen kivételkezelő osztály létezik a Java-ban.',133,0),
('Saját kivételkezelő osztály nem lehet származtatva az Exception osztályból.',134,0),
('Unchecked kivételek csak az objektumok létrehozásánál fordulnak elő.',135,0),
('A try-catch szerkezet csak az objektumok létrehozásánál alkalmazható.',136,0),
('A finally kulcsszó csak az objektumok létrehozásánál alkalmazható.',137,0),
('A predicate-ek csak az objektumok létrehozásánál alkalmazhatók.',138,0),
('A functional interface-ek csak az objektumok létrehozásánál alkalmazhatók.',139,0),
('A lambda kifejezések csak az objektumok létrehozásánál alkalmazhatók.',140,0),
('A lambda kifejezések szintaxisa csak az objektumok létrehozásánál alkalmazható.',141,0),
('A StreamAPI csak az objektumok létrehozásánál alkalmazható.',142,0),
('A Stream API szintaxisa csak az objektumok létrehozásánál alkalmazható.',143,0),
('A szálak létrehozásához a Runnable interfészt használjuk.',144,0),
('A többszálú alkalmazások készítése csak az objektumok létrehozásánál lehetséges.',145,0),
('A synchronized kulcsszót csak az objektumok létrehozásánál lehet alkalmazni.',146,0),
('A start metódus csak az objektumok létrehozásánál hasznos.',147,0),
('A join metódus csak az objektumok létrehozásánál hasznos.',148,0),
('A sleep metódus csak az objektumok létrehozásánál hasznos.',149,0),
('A többszálú alkalmazások készítése csak az objektumok létrehozásánál lehetséges.',150,0),
('Az URL osztály csak az objektumok létrehozásánál hasznos.',151,0),
('Az XML csak az objektumok létrehozásánál alkalmazható.',152,0),
('A Gson osztály csak az objektumok létrehozásánál hasznos.',153,0),
('Az XML feldolgozásához csak az eljárás-orientált programozásban van szükség.',154,0),
('A JSON feldolgozásához csak az eljárás-orientált programozásban van szükség.',155,0),
('A Timer és TimerTask osztályokat csak az eljárás-orientált programozásban lehet hasznos.',156,0),
('A Reflection API csak az eljárás-orientált programozásban lehet hasznos.',157,0),
('A legfontosabb osztályok a java.lang csomagban találhatóak.',158,0),
('A Connection osztály csak az objektumok létrehozásánál hasznos.',159,0),
('A Statement osztály csak az objektumok létrehozásánál hasznos.',160,0),
('A DriverManager osztály csak az objektumok létrehozásánál hasznos.',161,0),
('Az SQLException osztály csak az objektumok létrehozásánál hasznos.',162,0),
('A Prepared Statement csak objektumok létrehozására szolgál.',163,0),
('A ResultSet csak a szöveges programozásban hasznos.',164,0),
('A ResultSet indexei karaktereket használnak.',165,0),
('A JPA csak az objektumok létrehozására szolgál.',166,0),
('A Hibernate csak az objektumok létrehozására szolgál.',167,0),
('Az esemény-vezérelt alkalmazások csak az objektumok létrehozásánál hasznosak.',168,0),
('Esemény csak rendszeresemény lehet.',169,0),
('Az események csak rendszeresemények és felhasználói események két csoportba sorolhatók.',170,0),
('Minden esetben csak Swing-et érdemes használni.',171,0),
('A look-and-feel támogatás csak az objektumok létrehozásához hasznos.',172,0),
('A Swing-es grafikus felület csak az objektumok létrehozásához hasznos.',173,0),
('A felugró ablakot csak a szöveges programozásban lehet készíteni.',174,0),
('A pipálható mezőt csak a szöveges programozásban lehet készíteni.',175,0),
('A rádió gombot csak a szöveges programozásban lehet készíteni.',176,0),
('A legördülő menüt csak a szöveges programozásban lehet készíteni.',177,0),
('A címkét csak a szöveges programozásban lehet készíteni.',178,0),
('A szöveges beviteli mezőt csak a szöveges programozásban lehet készíteni.',179,0),
('A jelszó típusú beviteli mezőt csak a szöveges programozásban lehet készíteni.',180,0),
('A gombot csak a szöveges programozásban lehet készíteni.',181,0),
('A tárolót csak a szöveges programozásban lehet készíteni.',182,0),
('A komponensek csoportosítását csak a szöveges programozásban lehet készíteni.',183,0),
('A JavaFX-es grafikus felület csak az objektumok létrehozásával valósítható meg.',184,0),
('A Swing csak BorderLayout-ot támogat.',185,0),
('A JavaFX csak GridPane-et támogat.',186,0),
('A láthatóságot csak szöveges programozásban lehet beállítani.',187,0),
('Az elérhetőséget csak szöveges programozásban lehet beállítani.',188,0),
('A Maven csak grafikus felülettel használható.',189,0),
('A pom.xml csak a tesztek konfigurációját tartalmazza.',190,0),
('Az életciklus csak a csomagolásig tart.',191,0),
('A test csak a teszteket futtatja le.',192,0),
('A függőség csak a teszteket érinti.',193,0),
('A dependenciákat csak a lokális hálózaton található könyvtárból lehet letölteni.',194,0),
('A lokális repozitórium csak a telepített szoftverek tárolására szolgál.',195,0),
('A lokális repozitórium csak az install műveletkor érhető el.',196,0),
('Az artifactId csak a projekt verzióját határozza meg.',197,0),
('A groupId csak a projekt verzióját határozza meg.',198,0),
('A kliens-szerver kommunikáció során mindig a szerver küldi az üzeneteket.',199,0),
('Az HTTP mindig titkosított kapcsolaton keresztül történik.',200,0),
('Az 404 Not Found mindig azt jelenti, hogy a kérés sikertelen.',201,0),
('A Full Platform csak a Servlet technológiát tartalmazza.',202,0),
('SOAP csak bináris adatokat támogat.',203,0),
('A szervletek csak adatbázisokkal való kommunikációra használhatók.',204,0),
('A szervletek csak doGet metódust használhatnak.',205,0),
('A JSP csak adatbázisokkal való kommunikációra használható.',206,0),
('Az include parancs csak JavaScript kódok beillesztésére használható.',207,0),
('A JAR fájlokat csak a PATH környezeti változó segítségével lehet telepíteni.',208,0),
('A bean-ek csak a felhasználói felület reprezentációjára használhatók.',209,0),
('A JSTL csak adatelérésre használható.',210,0),
('A Spring Boot MVC modell csak a felhasználói felülettel való kommunikációra szolgál.',211,0),
('A Spring Boot alkalmazás csak IDE használatával hozható létre.',212,0),
('A Spring Boot Auto-configuration csak az adateléréssel foglalkozik.',213,0),
('Az OOP nyelvek mindig bonyolultabbak és kevésbé olvashatók.',1,0),
('Az absztrakció csak a fejlesztőknek fontos, a felhasználók nem értik.',2,0),
('A megkülönböztetés csak az OOP nyelvekben hasznos.',3,0),
('Az osztályozás csak a fejlesztőknek fontos, a felhasználók nem értik.',4,0),
('Az általánosítás csak az OOP nyelvekben hasznos.',5,0),
('Az OOP csak az objektumok közötti kapcsolatokat bonyolítja.',6,0),
('Az osztályok csak az eljárás-orientált programokban hasznosak.',7,0),
('Az objektumpéldányok csak az eljárás-orientált programokban hasznosak.',8,0),
('Az Object osztály csak a szöveges programozásban fontos.',9,0),
('A Wrapper osztályok csak a szöveges programozásban fontosak.',10,0),
('A "super" kulcsszó csak a szöveges programozásban fontos.',11,0),
('Az "extends" kulcsszó csak a szöveges programozásban fontos.',12,0),
('Az "implements" kulcsszó csak az objektumok létrehozásánál hasznos.',13,0),
('A POJO csak a szöveges programozásban fontos.',14,0),
('Az egységbezárás csak az öröklődésnél használható.',15,0),
('Az információrejtés csak az öröklődésnél használható.',16,0),
('Az öröklődés csak az interfészek implementálásánál használható.',17,0),
('A polimorfizmus csak az interfészek implementálásánál használható.',18,0),
('A konstruktor csak az interfészek implementálásánál használható.',19,0),
('A konstruktor csak az interfészek implementálásánál használható',20,0),
('A konstruktor túlterhelése csak az interfészek implementálásánál használható.',21,0),
('A destruktor csak az interfészek implementálásánál használható.',22,0),
('A Garbage Collector csak az interfészek implementálásánál használható.',23,0),
('A láthatósági szintek csak az interfészek implementálásánál használhatók.',24,0),
('A nem látható mező eléréséhez elegendő a default láthatóság. A nem látható mező elérhető mindenhol.',25,0),
('A "static" kulcsszó csak az interfészek implementálásánál használható.',26,0),
('A "final" kulcsszó csak az interfészek implementálásánál használható.',27,0),
('A "this" kulcsszó csak az interfészek implementálásánál használható.',28,0),
('A mező csak az interfészek implementálásánál használható.',29,0),
('A property csak az interfészek implementálásánál használható.',30,0),
('Getterek és setterek csak az interfészek implementálásánál használhatók.',31,0),
('Konvenció szerint a konstruktorokat mindig a mezők elé kell helyezni.',32,0),
('Többszörös öröklődés esetén az osztályoknak az összes interfészt implementálniuk kell. Többszörös öröklődés csak az eljárás-orientált programokban hasznos.',33,0),
('A Java SE csak az interfészek implementálásánál használható.',34,0),
('A Java EE csak a szöveges programozásban fontos.',35,0),
('A JDK csak a szöveges programozásban fontos.',36,0),
('A JRE csak a szöveges programozásban fontos.',37,0),
('A JVM csak a szöveges programozásban fontos.',38,0),
('A "javac" csak az interfészek implementálásánál használható.',39,0),
('A JIT csak a szöveges programozásban fontos.',40,0),
('A Java kódok fordítása csak az interfészek implementálásánál használható.',41,0),
('A "java.io" csomag használata csak az interfészek implementálásánál használható.',42,0),
('A "java.sql" csomag használata csak az interfészek implementálásánál használható.',43,0),
('A "java.awt" csomag használata csak az interfészek implementálásánál használható.',44,0),
('A "java.math" csomag használata csak az interfészek implementálásánál használható.',45,0),
('A "java.beans" csomag használata csak az interfészek implementálásánál használható.',46,0),
('A "java.util" csomag használata csak az interfészek implementálásánál használható.',47,0),
('A "Math" osztály csak az interfészek implementálásánál használható.',48,0),
('A primitív típusok csak az interfészek implementálásánál használhatók.',49,0),
('Az összetett típusok csak a logikai operátorok alkalmazásánál fontosak.',50,0),
('A matematikai operátorok csak a logikai operátorokkal kombinálva használhatók.',51,0),
('A relációs operátorok csak a logikai operátorokkal kombinálva használhatók.',52,0),
('A logikai operátorok csak az objektumok létrehozásánál alkalmazhatók.',53,0),
('Prefix és postfix értéknövelés csak a relációs operátorokkal kombinálva használható.',54,0),
('A "BufferedReader" csak a relációs operátorokkal kombinálva használhatók.',55,0),
('Az adatok átalakítása String típusba csak a relációs operátorokkal kombinálva használhatók.',56,0),
('A Java erősen típusos nyelv csak a relációs operátorokkal kombinálva használhatók.',57,0),
('A változó létrehozásának szempontjai csak a relációs operátorokkal kombinálva használhatók.',58,0),
('A switch-case szerkezet csak a relációs operátorokkal kombinálva használhatók.',59,0),
('A "default" ág csak a relációs operátorokkal kombinálva használhatók.',60,0),
('A "break" csak a relációs operátorokkal kombinálva használhatók.',61,0),
('A "break" és "continue" csak a relációs operátorokkal kombinálva használhatók.',62,0),
('A ciklusok Java-ban csak az eljárás-orientált programokban hasznosak.',63,0),
('Az elágazások Java-ban csak az eljárás-orientált programokban hasznosak.',64,0),
('A "while" és "do-while" ciklusok közötti különbség csak az eljárás-orientált programokban hasznosak.',65,0),
('A programozási tételek csak az eljárás-orientált programokban hasznosak.',66,0),
('A "void" kulcsszó használata csak az eljárás-orientált programokban hasznosak.',67,0),
('Az aktuális paraméterek csak a relációs operátorokkal kombinálva használhatók.',68,0),
('A metódus túlterhelése csak a relációs operátorokkal kombinálva használhatók.',69,0),
('A metódus szignatúrája csak a relációs operátorokkal kombinálva használhatók.',70,0),
('A metódus deklaráció és hívás közötti különbség csak az eljárás-orientált programokban hasznosak.',71,0),
('A tömbök használata csak a relációs operátorokkal kombinálva használhatók',72,0),
('A tömb elemeinek hivatkozása csak az eljárás-orientált programokban hasznosak.',73,0),
('A tömbkezelő metódusok csak a relációs operátorokkal kombinálva használhatók.',74,0),
('Rendező algoritmusok csak a relációs operátorokkal kombinálva vannak.',75,0),
('A rendező algoritmusok jóságát meghatározza csak a relációs operátorokkal kombinálva.',76,0),
('Fájl létrehozása csak a relációs operátorokkal kombinálva használhatók.',77,0),
('A fájl lezárása csak a relációs operátorokkal kombinálva fontos.',78,0),
('Fájlból olvasás csak a relációs operátorokkal kombinálva lehetséges.',79,0),
('A pointerek csak a relációs operátorokkal kombinálva vannak.',80,0),
('A split függvényt csak a relációs operátorokkal kombinálva lehet használni.',81,0),
('A "split" metódust csak a relációs operátorokkal kombinálva használhatók.',82,0),
('A "concat" metódust csak a relációs operátorokkal kombinálva használhatók.',83,0),
('A "format" metódust csak a relációs operátorokkal kombinálva használhatók.',84,0),
('A "substring" metódust csak a relációs operátorokkal kombinálva használhatók.',85,0),
('A "contains" metódust csak a relációs operátorokkal kombinálva használhatók.',86,0),
('Az "equals" metódust csak a relációs operátorokkal kombinálva használhatók.',87,0),
('A "replace" metódust csak a relációs operátorokkal kombinálva használhatók.',88,0),
('Az "indexOf" metódust csak a relációs operátorokkal kombinálva használhatók.',89,0),
('A java.text package-ben található dátumkezelő osztályokat érdemes használni.',90,0),
('A java.sql.Date osztály is elavult.',91,0),
('A dátumok összehasonlítása csak az eljárás-orientált programokban hasznos.',92,0),
('Rekurzióval csak a relációs operátorokkal kombinálva kapcsolatos feladatok oldhatók meg.',93,0),
('A rekurzív algoritmusok csak az eljárás-orientált programokban hasznosak.',94,0),
('A Java LTS verziói csak az eljárás-orientált programokban vannak.',95,0),
('A Java 8 újdonságai csak az eljárás-orientált programokban vannak.',96,0),
('A Java 11 újdonságai csak az eljárás-orientált programokban vannak.',97,0),
('A Java 17 újdonságai csak az eljárás-orientált programokban vannak.',98,0),
('A JCF csak az eljárás-orientált programokban hasznos.',99,0),
('A JCF csak az objektumok létrehozásánál alkalmazhatók.',100,0),
('A List interfész csak az eljárás-orientált programokban hasznos.',101,0),
('A Set interfész csak az eljárás-orientált programokban hasznos.',102,0),
('A Map interfész csak az eljárás-orientált programokban hasznos.',103,0),
('A List interfész implementációi csak az eljárás-orientált programokban vannak.',104,0),
('A Set interfész implementációi csak az eljárás-orientált programokban vannak.',105,0),
('A Map interfész implementációi csak az eljárás-orientált programokban vannak.',106,0),
('Az ArrayList osztály csak az eljárás-orientált programokban hasznos.',107,0),
('A LinkedList osztály csak az eljárás-orientált programokban hasznos.',108,0),
('A Stack osztály csak az eljárás-orientált programokban hasznos.',109,0),
('A Hashtable osztály csak az eljárás-orientált programokban hasznos.',110,0),
('Az ArrayList osztály exclude(int index) metódusával lehet index alapján eltávolítani egy elemet.',111,0),
('Az Collections osztály order metódusával lehet csökkenő sorrendbe rendezni egy listát.',112,0),
('Az Collections osztály order metódusával lehet növekvő sorrendbe rendezni egy listát.',113,0),
('Az ArrayList csak az eljárás-orientált programokban hasznos, a sima tömb pedig csak a szöveges programozásban alkalmazható.',114,0),
('Az ArrayList osztály csak az objektumok létrehozásánál alkalmazhatók.',115,0),
('Az absztrakt osztályok csak az objektumok létrehozásánál alkalmazhatók.',116,0),
('A Hashtable osztálynál csak az objektumok létrehozásánál alkalmazhatók a for ciklusok.',117,0),
('Az interface-ek csak az eljárás-orientált programokban hasznosak.',118,0),
('Az alkalmazás rétegezett felépítése csak az eljárás-orientált programokban hasznos.',119,0),
('Az MVC tervezési minta csak az eljárás-orientált programokban hasznos.',120,0),
('A Model réteg csak az eljárás-orientált programokban hasznos.',121,0),
('A View réteg csak az eljárás-orientált programokban hasznos.',122,0),
('A Controller réteg csak az eljárás-orientált programokban hasznos.',123,0),
('Az MVP tervezési minta csak az eljárás-orientált programokban hasznos.',124,0),
('Az MVVM tervezési minta csak az eljárás-orientált programokban hasznos.',125,0),
('A DTO-k csak az eljárás-orientált programokban hasznosak.',126,0),
('A DAO réteg csak az eljárás-orientált programokban hasznos.',127,0),
('A service réteg csak az eljárás-orientált programokban hasznos.',128,0),
('A repository réteg csak az eljárás-orientált programokban hasznos.',129,0),
('A reguláris kifejezéseket csak az eljárás-orientált programokban hasznos.',130,0),
('A reguláris kifejezésekben nincsenek speciális karakterek.',131,0),
('A kivételek csak az eljárás-orientált programokban hasznosak.',132,0),
('A kivételkezelő osztályok nem tartalmaznak információt a hibáról.',133,0),
('Saját kivételkezelő osztály létrehozásához nincs szükség konstruktorra.',134,0),
('Checked kivételek csak az eljárás-orientált programokban fordulnak elő.',135,0),
('A try-catch szerkezet csak az eljárás-orientált programokban hasznos.',136,0),
('A finally kulcsszó csak az eljárás-orientált programokban hasznos.',137,0),
('A predicate-ek csak az eljárás-orientált programokban hasznosak.',138,0),
('A functional interface-ek csak az eljárás-orientált programokban hasznosak.',139,0),
('A lambda kifejezések csak az eljárás-orientált programokban hasznosak.',140,0),
('A lambda kifejezések szintaxisa csak az eljárás-orientált programokban alkalmazható.',141,0),
('A StreamAPI csak az eljárás-orientált programokban hasznos.',142,0),
('A Stream API szintaxisa csak az eljárás-orientált programokban alkalmazható.',143,0),
('A szálak létrehozásához az Integer osztályt használjuk.',144,0),
('A többszálú alkalmazások készítése csak az eljárás-orientált programokban lehetséges.',145,0),
('A synchronized kulcsszót csak az eljárás-orientált programokban lehet hasznos.',146,0),
('A start metódus csak az eljárás-orientált programokban hasznos.',147,0),
('A join metódus csak az eljárás-orientált programokban hasznos.',148,0),
('A sleep metódus csak az eljárás-orientált programokban hasznos.',149,0),
('A többszálú alkalmazások készítése csak az eljárás-orientált programokban lehetséges.',150,0),
('Az URL osztály csak az eljárás-orientált programokban hasznos.',151,0),
('A JSON csak az eljárás-orientált programokban hasznos.',152,0),
('A Gson osztály csak az eljárás-orientált programokban hasznos.',153,0),
('Az XML feldolgozásához csak a szöveges programozásban van szükség.',154,0),
('A JSON feldolgozásához csak a szöveges programozásban van szükség.',155,0),
('A Timer és TimerTask osztályokat csak a szöveges programozásban lehet hasznos.',156,0),
('A Reflection API csak a szöveges programozásban lehet hasznos.',157,0),
('A legfontosabb osztályok a java.io csomagban találhatóak.',158,0),
('A Connection osztály csak az eljárás-orientált programokban hasznos.',159,0),
('A Statement osztály csak az eljárás-orientált programokban hasznos.',160,0),
('A DriverManager osztály csak az eljárás-orientált programokban hasznos.',161,0),
('Az SQLException osztály csak az eljárás-orientált programokban hasznos.',162,0),
('A Prepared Statement csak a szöveges programozásban hasznos.',163,0),
('A ResultSet csak az eljárás-orientált programokban hasznos.',164,0),
('A ResultSet indexei csak az objektumok létrehozására szolgálnak.',165,0),
('A JPA csak az eljárás-orientált programokban hasznos.',166,0),
('A Hibernate csak az eljárás-orientált programokban hasznos.',167,0),
('Az esemény-vezérelt alkalmazások csak az eljárás-orientált programozásban lehetségesek.',168,0),
('Esemény csak egyéb esemény lehet.',169,0),
('Az események csak az objektumok létrehozásához tartozhatnak.',170,0),
('Minden esetben csak JavaFX-et érdemes használni.',171,0),
('A look-and-feel támogatás csak az eljárás-orientált programokban hasznos.',172,0),
('A Swing-es grafikus felület csak az eljárás-orientált programokban lehetséges.',173,0),
('A felugró ablak csak az eljárás-orientált programozásban hasznos.',174,0),
('A pipálható mező csak az eljárás-orientált programokban hasznos.',175,0),
('A rádió gomb csak az eljárás-orientált programokban hasznos.',176,0),
('A legördülő menü csak az eljárás-orientált programokban hasznos.',177,0),
('A címke csak az eljárás-orientált programokban hasznos.',178,0),
('A szöveges beviteli mező csak az eljárás-orientált programokban hasznos.',179,0),
('A jelszó típusú beviteli mező csak az eljárás-orientált programokban hasznos.',180,0),
('A gomb csak az eljárás-orientált programokban hasznos.',181,0),
('A tároló csak az eljárás-orientált programokban hasznos.',182,0),
('A komponensek csoportosítása csak az eljárás-orientált programokban hasznos.',183,0),
('A JavaFX-es grafikus felület csak az eljárás-orientált programokban hozható létre.',184,0),
('A Swing csak FlowLayout-ot támogat.',185,0),
('A JavaFX csak VBox-ot támogat.',186,0),
('A láthatóságot csak az eljárás-orientált programokban lehet beállítani.',187,0),
('Az elérhetőséget csak az eljárás-orientált programokban lehet beállítani.',188,0),
('A Maven csak a Java nyelvet támogatja.',189,0),
('A pom.xml csak a forráskód helyét határozza meg.',190,0),
('Az életciklus csak a telepítésig tart.',191,0),
('Az install csak az artifaktokat csomagolja.',192,0),
('A függőség csak a csomagolást érinti.',193,0),
('A dependenciákat csak a projekt forráskódjának részeként lehet letölteni.',194,0),
('A lokális repozitórium csak a projekt fájljainak tárolására szolgál.',195,0),
('A Maven csak az internetről tölti le a dependenciákat.',196,0),
('Az artifactId csak a csomagolás típusát határozza meg.',197,0),
('A groupId csak a csomagolás típusát határozza meg.',198,0),
('A kliens-szerver kommunikáció során nincs válasz a kérésre.',199,0),
('Az HTTP mindig más portot használ.',200,0),
('Az 500 Internal Server Error mindig azt jelenti, hogy a kérés sikeres.',201,0),
('A WebProfile és a Full Platform ugyanazt a technológiát tartalmazza.',202,0),
('SOAP csak egy protokoll az összetett webes szolgáltatásokban.',203,0),
('A szervletek csak JavaScript kódok végrehajtására alkalmasak.',204,0),
('A szervletek csak doPost metódust használhatnak.',205,0),
('A JSP csak JavaScript kódok végrehajtására alkalmas.',206,0),
('Az include parancs csak statikus tartalmak beillesztésére használható.',207,0),
('A JAR fájlokat csak a szervletes konténer beállítása során lehet telepíteni.',208,0),
('A bean-ek csak statikus tartalmat képesek kezelni.',209,0),
('A JSTL csak JavaScript kódok kezelésére használható.',210,0),
('A Spring Boot MVC modell csak statikus tartalmak kezelésére szolgál.',211,0),
('A Spring Boot alkalmazás csak egyetlen módon, a Spring Initializr segítségével hozható létre.',212,0),
('A Spring Boot Actuator csak az alkalmazás indításával foglalkozik.',213,0);
